// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUTUREHEADAPI_FUTUREHEADAPI_H_
#define FLATBUFFERS_GENERATED_FUTUREHEADAPI_FUTUREHEADAPI_H_

#include "flatbuffers/flatbuffers.h"

namespace futureheadapi {

struct AccountWeight;
struct AccountWeightBuilder;
struct AccountWeightT;

struct AccountWeightResponse;
struct AccountWeightResponseBuilder;
struct AccountWeightResponseT;

struct BlockOpen;
struct BlockOpenBuilder;
struct BlockOpenT;

struct BlockReceive;
struct BlockReceiveBuilder;
struct BlockReceiveT;

struct BlockSend;
struct BlockSendBuilder;
struct BlockSendT;

struct BlockChange;
struct BlockChangeBuilder;
struct BlockChangeT;

struct BlockState;
struct BlockStateBuilder;
struct BlockStateT;

struct BlockInfo;
struct BlockInfoBuilder;
struct BlockInfoT;

struct ServiceRegister;
struct ServiceRegisterBuilder;
struct ServiceRegisterT;

struct ServiceStop;
struct ServiceStopBuilder;
struct ServiceStopT;

struct TopicServiceStop;
struct TopicServiceStopBuilder;
struct TopicServiceStopT;

struct EventServiceStop;
struct EventServiceStopBuilder;
struct EventServiceStopT;

struct EventAck;
struct EventAckBuilder;
struct EventAckT;

struct TopicConfirmation;
struct TopicConfirmationBuilder;
struct TopicConfirmationT;

struct TopicConfirmationOptions;
struct TopicConfirmationOptionsBuilder;
struct TopicConfirmationOptionsT;

struct EventConfirmation;
struct EventConfirmationBuilder;
struct EventConfirmationT;

struct ElectionInfo;
struct ElectionInfoBuilder;
struct ElectionInfoT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct Success;
struct SuccessBuilder;
struct SuccessT;

struct IsAlive;
struct IsAliveBuilder;
struct IsAliveT;

struct Envelope;
struct EnvelopeBuilder;
struct EnvelopeT;

inline const flatbuffers::TypeTable *AccountWeightTypeTable();

inline const flatbuffers::TypeTable *AccountWeightResponseTypeTable();

inline const flatbuffers::TypeTable *BlockOpenTypeTable();

inline const flatbuffers::TypeTable *BlockReceiveTypeTable();

inline const flatbuffers::TypeTable *BlockSendTypeTable();

inline const flatbuffers::TypeTable *BlockChangeTypeTable();

inline const flatbuffers::TypeTable *BlockStateTypeTable();

inline const flatbuffers::TypeTable *BlockInfoTypeTable();

inline const flatbuffers::TypeTable *ServiceRegisterTypeTable();

inline const flatbuffers::TypeTable *ServiceStopTypeTable();

inline const flatbuffers::TypeTable *TopicServiceStopTypeTable();

inline const flatbuffers::TypeTable *EventServiceStopTypeTable();

inline const flatbuffers::TypeTable *EventAckTypeTable();

inline const flatbuffers::TypeTable *TopicConfirmationTypeTable();

inline const flatbuffers::TypeTable *TopicConfirmationOptionsTypeTable();

inline const flatbuffers::TypeTable *EventConfirmationTypeTable();

inline const flatbuffers::TypeTable *ElectionInfoTypeTable();

inline const flatbuffers::TypeTable *ErrorTypeTable();

inline const flatbuffers::TypeTable *SuccessTypeTable();

inline const flatbuffers::TypeTable *IsAliveTypeTable();

inline const flatbuffers::TypeTable *EnvelopeTypeTable();

enum BlockSubType {
  BlockSubType_invalid = 0,
  BlockSubType_receive = 1,
  BlockSubType_send = 2,
  BlockSubType_change = 3,
  BlockSubType_epoch = 4,
  BlockSubType_MIN = BlockSubType_invalid,
  BlockSubType_MAX = BlockSubType_epoch
};

inline const BlockSubType (&EnumValuesBlockSubType())[5] {
  static const BlockSubType values[] = {
    BlockSubType_invalid,
    BlockSubType_receive,
    BlockSubType_send,
    BlockSubType_change,
    BlockSubType_epoch
  };
  return values;
}

inline const char * const *EnumNamesBlockSubType() {
  static const char * const names[6] = {
    "invalid",
    "receive",
    "send",
    "change",
    "epoch",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlockSubType(BlockSubType e) {
  if (flatbuffers::IsOutRange(e, BlockSubType_invalid, BlockSubType_epoch)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlockSubType()[index];
}

enum Block {
  Block_NONE = 0,
  Block_BlockState = 1,
  Block_BlockOpen = 2,
  Block_BlockReceive = 3,
  Block_BlockSend = 4,
  Block_BlockChange = 5,
  Block_MIN = Block_NONE,
  Block_MAX = Block_BlockChange
};

inline const Block (&EnumValuesBlock())[6] {
  static const Block values[] = {
    Block_NONE,
    Block_BlockState,
    Block_BlockOpen,
    Block_BlockReceive,
    Block_BlockSend,
    Block_BlockChange
  };
  return values;
}

inline const char * const *EnumNamesBlock() {
  static const char * const names[7] = {
    "NONE",
    "BlockState",
    "BlockOpen",
    "BlockReceive",
    "BlockSend",
    "BlockChange",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlock(Block e) {
  if (flatbuffers::IsOutRange(e, Block_NONE, Block_BlockChange)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlock()[index];
}

template<typename T> struct BlockTraits {
  static const Block enum_value = Block_NONE;
};

template<> struct BlockTraits<futureheadapi::BlockState> {
  static const Block enum_value = Block_BlockState;
};

template<> struct BlockTraits<futureheadapi::BlockOpen> {
  static const Block enum_value = Block_BlockOpen;
};

template<> struct BlockTraits<futureheadapi::BlockReceive> {
  static const Block enum_value = Block_BlockReceive;
};

template<> struct BlockTraits<futureheadapi::BlockSend> {
  static const Block enum_value = Block_BlockSend;
};

template<> struct BlockTraits<futureheadapi::BlockChange> {
  static const Block enum_value = Block_BlockChange;
};

struct BlockUnion {
  Block type;
  void *value;

  BlockUnion() : type(Block_NONE), value(nullptr) {}
  BlockUnion(BlockUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Block_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BlockUnion(const BlockUnion &) FLATBUFFERS_NOEXCEPT;
  BlockUnion &operator=(const BlockUnion &u) FLATBUFFERS_NOEXCEPT
    { BlockUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BlockUnion &operator=(BlockUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BlockUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = BlockTraits<typename RT::TableType>::enum_value;
    if (type != Block_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Block type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  futureheadapi::BlockStateT *AsBlockState() {
    return type == Block_BlockState ?
      reinterpret_cast<futureheadapi::BlockStateT *>(value) : nullptr;
  }
  const futureheadapi::BlockStateT *AsBlockState() const {
    return type == Block_BlockState ?
      reinterpret_cast<const futureheadapi::BlockStateT *>(value) : nullptr;
  }
  futureheadapi::BlockOpenT *AsBlockOpen() {
    return type == Block_BlockOpen ?
      reinterpret_cast<futureheadapi::BlockOpenT *>(value) : nullptr;
  }
  const futureheadapi::BlockOpenT *AsBlockOpen() const {
    return type == Block_BlockOpen ?
      reinterpret_cast<const futureheadapi::BlockOpenT *>(value) : nullptr;
  }
  futureheadapi::BlockReceiveT *AsBlockReceive() {
    return type == Block_BlockReceive ?
      reinterpret_cast<futureheadapi::BlockReceiveT *>(value) : nullptr;
  }
  const futureheadapi::BlockReceiveT *AsBlockReceive() const {
    return type == Block_BlockReceive ?
      reinterpret_cast<const futureheadapi::BlockReceiveT *>(value) : nullptr;
  }
  futureheadapi::BlockSendT *AsBlockSend() {
    return type == Block_BlockSend ?
      reinterpret_cast<futureheadapi::BlockSendT *>(value) : nullptr;
  }
  const futureheadapi::BlockSendT *AsBlockSend() const {
    return type == Block_BlockSend ?
      reinterpret_cast<const futureheadapi::BlockSendT *>(value) : nullptr;
  }
  futureheadapi::BlockChangeT *AsBlockChange() {
    return type == Block_BlockChange ?
      reinterpret_cast<futureheadapi::BlockChangeT *>(value) : nullptr;
  }
  const futureheadapi::BlockChangeT *AsBlockChange() const {
    return type == Block_BlockChange ?
      reinterpret_cast<const futureheadapi::BlockChangeT *>(value) : nullptr;
  }
};

bool VerifyBlock(flatbuffers::Verifier &verifier, const void *obj, Block type);
bool VerifyBlockVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum TopicConfirmationTypeFilter {
  TopicConfirmationTypeFilter_all = 0,
  TopicConfirmationTypeFilter_active = 1,
  TopicConfirmationTypeFilter_active_quorum = 2,
  TopicConfirmationTypeFilter_active_confirmation_height = 3,
  TopicConfirmationTypeFilter_inactive = 4,
  TopicConfirmationTypeFilter_MIN = TopicConfirmationTypeFilter_all,
  TopicConfirmationTypeFilter_MAX = TopicConfirmationTypeFilter_inactive
};

inline const TopicConfirmationTypeFilter (&EnumValuesTopicConfirmationTypeFilter())[5] {
  static const TopicConfirmationTypeFilter values[] = {
    TopicConfirmationTypeFilter_all,
    TopicConfirmationTypeFilter_active,
    TopicConfirmationTypeFilter_active_quorum,
    TopicConfirmationTypeFilter_active_confirmation_height,
    TopicConfirmationTypeFilter_inactive
  };
  return values;
}

inline const char * const *EnumNamesTopicConfirmationTypeFilter() {
  static const char * const names[6] = {
    "all",
    "active",
    "active_quorum",
    "active_confirmation_height",
    "inactive",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopicConfirmationTypeFilter(TopicConfirmationTypeFilter e) {
  if (flatbuffers::IsOutRange(e, TopicConfirmationTypeFilter_all, TopicConfirmationTypeFilter_inactive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopicConfirmationTypeFilter()[index];
}

enum TopicConfirmationType {
  TopicConfirmationType_active_quorum = 0,
  TopicConfirmationType_active_confirmation_height = 1,
  TopicConfirmationType_inactive = 2,
  TopicConfirmationType_MIN = TopicConfirmationType_active_quorum,
  TopicConfirmationType_MAX = TopicConfirmationType_inactive
};

inline const TopicConfirmationType (&EnumValuesTopicConfirmationType())[3] {
  static const TopicConfirmationType values[] = {
    TopicConfirmationType_active_quorum,
    TopicConfirmationType_active_confirmation_height,
    TopicConfirmationType_inactive
  };
  return values;
}

inline const char * const *EnumNamesTopicConfirmationType() {
  static const char * const names[4] = {
    "active_quorum",
    "active_confirmation_height",
    "inactive",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopicConfirmationType(TopicConfirmationType e) {
  if (flatbuffers::IsOutRange(e, TopicConfirmationType_active_quorum, TopicConfirmationType_inactive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopicConfirmationType()[index];
}

enum Message {
  Message_NONE = 0,
  Message_Error = 1,
  Message_Success = 2,
  Message_IsAlive = 3,
  Message_EventAck = 4,
  Message_BlockInfo = 5,
  Message_AccountWeight = 6,
  Message_AccountWeightResponse = 7,
  Message_TopicConfirmation = 8,
  Message_EventConfirmation = 9,
  Message_ServiceRegister = 10,
  Message_ServiceStop = 11,
  Message_TopicServiceStop = 12,
  Message_EventServiceStop = 13,
  Message_MIN = Message_NONE,
  Message_MAX = Message_EventServiceStop
};

inline const Message (&EnumValuesMessage())[14] {
  static const Message values[] = {
    Message_NONE,
    Message_Error,
    Message_Success,
    Message_IsAlive,
    Message_EventAck,
    Message_BlockInfo,
    Message_AccountWeight,
    Message_AccountWeightResponse,
    Message_TopicConfirmation,
    Message_EventConfirmation,
    Message_ServiceRegister,
    Message_ServiceStop,
    Message_TopicServiceStop,
    Message_EventServiceStop
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[15] = {
    "NONE",
    "Error",
    "Success",
    "IsAlive",
    "EventAck",
    "BlockInfo",
    "AccountWeight",
    "AccountWeightResponse",
    "TopicConfirmation",
    "EventConfirmation",
    "ServiceRegister",
    "ServiceStop",
    "TopicServiceStop",
    "EventServiceStop",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_EventServiceStop)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<futureheadapi::Error> {
  static const Message enum_value = Message_Error;
};

template<> struct MessageTraits<futureheadapi::Success> {
  static const Message enum_value = Message_Success;
};

template<> struct MessageTraits<futureheadapi::IsAlive> {
  static const Message enum_value = Message_IsAlive;
};

template<> struct MessageTraits<futureheadapi::EventAck> {
  static const Message enum_value = Message_EventAck;
};

template<> struct MessageTraits<futureheadapi::BlockInfo> {
  static const Message enum_value = Message_BlockInfo;
};

template<> struct MessageTraits<futureheadapi::AccountWeight> {
  static const Message enum_value = Message_AccountWeight;
};

template<> struct MessageTraits<futureheadapi::AccountWeightResponse> {
  static const Message enum_value = Message_AccountWeightResponse;
};

template<> struct MessageTraits<futureheadapi::TopicConfirmation> {
  static const Message enum_value = Message_TopicConfirmation;
};

template<> struct MessageTraits<futureheadapi::EventConfirmation> {
  static const Message enum_value = Message_EventConfirmation;
};

template<> struct MessageTraits<futureheadapi::ServiceRegister> {
  static const Message enum_value = Message_ServiceRegister;
};

template<> struct MessageTraits<futureheadapi::ServiceStop> {
  static const Message enum_value = Message_ServiceStop;
};

template<> struct MessageTraits<futureheadapi::TopicServiceStop> {
  static const Message enum_value = Message_TopicServiceStop;
};

template<> struct MessageTraits<futureheadapi::EventServiceStop> {
  static const Message enum_value = Message_EventServiceStop;
};

struct MessageUnion {
  Message type;
  void *value;

  MessageUnion() : type(Message_NONE), value(nullptr) {}
  MessageUnion(MessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Message_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageUnion(const MessageUnion &) FLATBUFFERS_NOEXCEPT;
  MessageUnion &operator=(const MessageUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageUnion &operator=(MessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageTraits<typename RT::TableType>::enum_value;
    if (type != Message_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  futureheadapi::ErrorT *AsError() {
    return type == Message_Error ?
      reinterpret_cast<futureheadapi::ErrorT *>(value) : nullptr;
  }
  const futureheadapi::ErrorT *AsError() const {
    return type == Message_Error ?
      reinterpret_cast<const futureheadapi::ErrorT *>(value) : nullptr;
  }
  futureheadapi::SuccessT *AsSuccess() {
    return type == Message_Success ?
      reinterpret_cast<futureheadapi::SuccessT *>(value) : nullptr;
  }
  const futureheadapi::SuccessT *AsSuccess() const {
    return type == Message_Success ?
      reinterpret_cast<const futureheadapi::SuccessT *>(value) : nullptr;
  }
  futureheadapi::IsAliveT *AsIsAlive() {
    return type == Message_IsAlive ?
      reinterpret_cast<futureheadapi::IsAliveT *>(value) : nullptr;
  }
  const futureheadapi::IsAliveT *AsIsAlive() const {
    return type == Message_IsAlive ?
      reinterpret_cast<const futureheadapi::IsAliveT *>(value) : nullptr;
  }
  futureheadapi::EventAckT *AsEventAck() {
    return type == Message_EventAck ?
      reinterpret_cast<futureheadapi::EventAckT *>(value) : nullptr;
  }
  const futureheadapi::EventAckT *AsEventAck() const {
    return type == Message_EventAck ?
      reinterpret_cast<const futureheadapi::EventAckT *>(value) : nullptr;
  }
  futureheadapi::BlockInfoT *AsBlockInfo() {
    return type == Message_BlockInfo ?
      reinterpret_cast<futureheadapi::BlockInfoT *>(value) : nullptr;
  }
  const futureheadapi::BlockInfoT *AsBlockInfo() const {
    return type == Message_BlockInfo ?
      reinterpret_cast<const futureheadapi::BlockInfoT *>(value) : nullptr;
  }
  futureheadapi::AccountWeightT *AsAccountWeight() {
    return type == Message_AccountWeight ?
      reinterpret_cast<futureheadapi::AccountWeightT *>(value) : nullptr;
  }
  const futureheadapi::AccountWeightT *AsAccountWeight() const {
    return type == Message_AccountWeight ?
      reinterpret_cast<const futureheadapi::AccountWeightT *>(value) : nullptr;
  }
  futureheadapi::AccountWeightResponseT *AsAccountWeightResponse() {
    return type == Message_AccountWeightResponse ?
      reinterpret_cast<futureheadapi::AccountWeightResponseT *>(value) : nullptr;
  }
  const futureheadapi::AccountWeightResponseT *AsAccountWeightResponse() const {
    return type == Message_AccountWeightResponse ?
      reinterpret_cast<const futureheadapi::AccountWeightResponseT *>(value) : nullptr;
  }
  futureheadapi::TopicConfirmationT *AsTopicConfirmation() {
    return type == Message_TopicConfirmation ?
      reinterpret_cast<futureheadapi::TopicConfirmationT *>(value) : nullptr;
  }
  const futureheadapi::TopicConfirmationT *AsTopicConfirmation() const {
    return type == Message_TopicConfirmation ?
      reinterpret_cast<const futureheadapi::TopicConfirmationT *>(value) : nullptr;
  }
  futureheadapi::EventConfirmationT *AsEventConfirmation() {
    return type == Message_EventConfirmation ?
      reinterpret_cast<futureheadapi::EventConfirmationT *>(value) : nullptr;
  }
  const futureheadapi::EventConfirmationT *AsEventConfirmation() const {
    return type == Message_EventConfirmation ?
      reinterpret_cast<const futureheadapi::EventConfirmationT *>(value) : nullptr;
  }
  futureheadapi::ServiceRegisterT *AsServiceRegister() {
    return type == Message_ServiceRegister ?
      reinterpret_cast<futureheadapi::ServiceRegisterT *>(value) : nullptr;
  }
  const futureheadapi::ServiceRegisterT *AsServiceRegister() const {
    return type == Message_ServiceRegister ?
      reinterpret_cast<const futureheadapi::ServiceRegisterT *>(value) : nullptr;
  }
  futureheadapi::ServiceStopT *AsServiceStop() {
    return type == Message_ServiceStop ?
      reinterpret_cast<futureheadapi::ServiceStopT *>(value) : nullptr;
  }
  const futureheadapi::ServiceStopT *AsServiceStop() const {
    return type == Message_ServiceStop ?
      reinterpret_cast<const futureheadapi::ServiceStopT *>(value) : nullptr;
  }
  futureheadapi::TopicServiceStopT *AsTopicServiceStop() {
    return type == Message_TopicServiceStop ?
      reinterpret_cast<futureheadapi::TopicServiceStopT *>(value) : nullptr;
  }
  const futureheadapi::TopicServiceStopT *AsTopicServiceStop() const {
    return type == Message_TopicServiceStop ?
      reinterpret_cast<const futureheadapi::TopicServiceStopT *>(value) : nullptr;
  }
  futureheadapi::EventServiceStopT *AsEventServiceStop() {
    return type == Message_EventServiceStop ?
      reinterpret_cast<futureheadapi::EventServiceStopT *>(value) : nullptr;
  }
  const futureheadapi::EventServiceStopT *AsEventServiceStop() const {
    return type == Message_EventServiceStop ?
      reinterpret_cast<const futureheadapi::EventServiceStopT *>(value) : nullptr;
  }
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AccountWeightT : public flatbuffers::NativeTable {
  typedef AccountWeight TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.AccountWeightT";
  }
  std::string account;
  AccountWeightT() {
  }
};

struct AccountWeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AccountWeightT NativeTableType;
  typedef AccountWeightBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AccountWeightTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.AccountWeight";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
  AccountWeightT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccountWeightT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AccountWeight> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccountWeightBuilder {
  typedef AccountWeight Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(AccountWeight::VT_ACCOUNT, account);
  }
  explicit AccountWeightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountWeightBuilder &operator=(const AccountWeightBuilder &);
  flatbuffers::Offset<AccountWeight> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountWeight>(end);
    fbb_.Required(o, AccountWeight::VT_ACCOUNT);
    return o;
  }
};

inline flatbuffers::Offset<AccountWeight> CreateAccountWeight(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0) {
  AccountWeightBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountWeight> CreateAccountWeightDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return futureheadapi::CreateAccountWeight(
      _fbb,
      account__);
}

flatbuffers::Offset<AccountWeight> CreateAccountWeight(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccountWeightResponseT : public flatbuffers::NativeTable {
  typedef AccountWeightResponse TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.AccountWeightResponseT";
  }
  std::string voting_weight;
  AccountWeightResponseT() {
  }
};

struct AccountWeightResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AccountWeightResponseT NativeTableType;
  typedef AccountWeightResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AccountWeightResponseTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.AccountWeightResponse";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOTING_WEIGHT = 4
  };
  const flatbuffers::String *voting_weight() const {
    return GetPointer<const flatbuffers::String *>(VT_VOTING_WEIGHT);
  }
  flatbuffers::String *mutable_voting_weight() {
    return GetPointer<flatbuffers::String *>(VT_VOTING_WEIGHT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VOTING_WEIGHT) &&
           verifier.VerifyString(voting_weight()) &&
           verifier.EndTable();
  }
  AccountWeightResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccountWeightResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AccountWeightResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccountWeightResponseBuilder {
  typedef AccountWeightResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_voting_weight(flatbuffers::Offset<flatbuffers::String> voting_weight) {
    fbb_.AddOffset(AccountWeightResponse::VT_VOTING_WEIGHT, voting_weight);
  }
  explicit AccountWeightResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountWeightResponseBuilder &operator=(const AccountWeightResponseBuilder &);
  flatbuffers::Offset<AccountWeightResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AccountWeightResponse>(end);
    fbb_.Required(o, AccountWeightResponse::VT_VOTING_WEIGHT);
    return o;
  }
};

inline flatbuffers::Offset<AccountWeightResponse> CreateAccountWeightResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> voting_weight = 0) {
  AccountWeightResponseBuilder builder_(_fbb);
  builder_.add_voting_weight(voting_weight);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountWeightResponse> CreateAccountWeightResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *voting_weight = nullptr) {
  auto voting_weight__ = voting_weight ? _fbb.CreateString(voting_weight) : 0;
  return futureheadapi::CreateAccountWeightResponse(
      _fbb,
      voting_weight__);
}

flatbuffers::Offset<AccountWeightResponse> CreateAccountWeightResponse(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockOpenT : public flatbuffers::NativeTable {
  typedef BlockOpen TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockOpenT";
  }
  std::string hash;
  std::string account;
  std::string source;
  std::string representative;
  std::string signature;
  std::string work;
  BlockOpenT() {
  }
};

struct BlockOpen FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockOpenT NativeTableType;
  typedef BlockOpenBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockOpenTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockOpen";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_ACCOUNT = 6,
    VT_SOURCE = 8,
    VT_REPRESENTATIVE = 10,
    VT_SIGNATURE = 12,
    VT_WORK = 14
  };
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *source() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE);
  }
  flatbuffers::String *mutable_source() {
    return GetPointer<flatbuffers::String *>(VT_SOURCE);
  }
  const flatbuffers::String *representative() const {
    return GetPointer<const flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  flatbuffers::String *mutable_representative() {
    return GetPointer<flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  flatbuffers::String *mutable_signature() {
    return GetPointer<flatbuffers::String *>(VT_SIGNATURE);
  }
  const flatbuffers::String *work() const {
    return GetPointer<const flatbuffers::String *>(VT_WORK);
  }
  flatbuffers::String *mutable_work() {
    return GetPointer<flatbuffers::String *>(VT_WORK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_REPRESENTATIVE) &&
           verifier.VerifyString(representative()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_WORK) &&
           verifier.VerifyString(work()) &&
           verifier.EndTable();
  }
  BlockOpenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockOpenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockOpen> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockOpenBuilder {
  typedef BlockOpen Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(BlockOpen::VT_HASH, hash);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(BlockOpen::VT_ACCOUNT, account);
  }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) {
    fbb_.AddOffset(BlockOpen::VT_SOURCE, source);
  }
  void add_representative(flatbuffers::Offset<flatbuffers::String> representative) {
    fbb_.AddOffset(BlockOpen::VT_REPRESENTATIVE, representative);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(BlockOpen::VT_SIGNATURE, signature);
  }
  void add_work(flatbuffers::Offset<flatbuffers::String> work) {
    fbb_.AddOffset(BlockOpen::VT_WORK, work);
  }
  explicit BlockOpenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockOpenBuilder &operator=(const BlockOpenBuilder &);
  flatbuffers::Offset<BlockOpen> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockOpen>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockOpen> CreateBlockOpen(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0,
    flatbuffers::Offset<flatbuffers::String> representative = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    flatbuffers::Offset<flatbuffers::String> work = 0) {
  BlockOpenBuilder builder_(_fbb);
  builder_.add_work(work);
  builder_.add_signature(signature);
  builder_.add_representative(representative);
  builder_.add_source(source);
  builder_.add_account(account);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockOpen> CreateBlockOpenDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hash = nullptr,
    const char *account = nullptr,
    const char *source = nullptr,
    const char *representative = nullptr,
    const char *signature = nullptr,
    const char *work = nullptr) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto representative__ = representative ? _fbb.CreateString(representative) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto work__ = work ? _fbb.CreateString(work) : 0;
  return futureheadapi::CreateBlockOpen(
      _fbb,
      hash__,
      account__,
      source__,
      representative__,
      signature__,
      work__);
}

flatbuffers::Offset<BlockOpen> CreateBlockOpen(flatbuffers::FlatBufferBuilder &_fbb, const BlockOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockReceiveT : public flatbuffers::NativeTable {
  typedef BlockReceive TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockReceiveT";
  }
  std::string hash;
  std::string previous;
  std::string source;
  std::string signature;
  std::string work;
  BlockReceiveT() {
  }
};

struct BlockReceive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockReceiveT NativeTableType;
  typedef BlockReceiveBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockReceiveTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockReceive";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_PREVIOUS = 6,
    VT_SOURCE = 8,
    VT_SIGNATURE = 10,
    VT_WORK = 12
  };
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *previous() const {
    return GetPointer<const flatbuffers::String *>(VT_PREVIOUS);
  }
  flatbuffers::String *mutable_previous() {
    return GetPointer<flatbuffers::String *>(VT_PREVIOUS);
  }
  const flatbuffers::String *source() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE);
  }
  flatbuffers::String *mutable_source() {
    return GetPointer<flatbuffers::String *>(VT_SOURCE);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  flatbuffers::String *mutable_signature() {
    return GetPointer<flatbuffers::String *>(VT_SIGNATURE);
  }
  const flatbuffers::String *work() const {
    return GetPointer<const flatbuffers::String *>(VT_WORK);
  }
  flatbuffers::String *mutable_work() {
    return GetPointer<flatbuffers::String *>(VT_WORK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyString(previous()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_WORK) &&
           verifier.VerifyString(work()) &&
           verifier.EndTable();
  }
  BlockReceiveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockReceiveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockReceive> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockReceiveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockReceiveBuilder {
  typedef BlockReceive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(BlockReceive::VT_HASH, hash);
  }
  void add_previous(flatbuffers::Offset<flatbuffers::String> previous) {
    fbb_.AddOffset(BlockReceive::VT_PREVIOUS, previous);
  }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) {
    fbb_.AddOffset(BlockReceive::VT_SOURCE, source);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(BlockReceive::VT_SIGNATURE, signature);
  }
  void add_work(flatbuffers::Offset<flatbuffers::String> work) {
    fbb_.AddOffset(BlockReceive::VT_WORK, work);
  }
  explicit BlockReceiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockReceiveBuilder &operator=(const BlockReceiveBuilder &);
  flatbuffers::Offset<BlockReceive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockReceive>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockReceive> CreateBlockReceive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> previous = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    flatbuffers::Offset<flatbuffers::String> work = 0) {
  BlockReceiveBuilder builder_(_fbb);
  builder_.add_work(work);
  builder_.add_signature(signature);
  builder_.add_source(source);
  builder_.add_previous(previous);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockReceive> CreateBlockReceiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hash = nullptr,
    const char *previous = nullptr,
    const char *source = nullptr,
    const char *signature = nullptr,
    const char *work = nullptr) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto previous__ = previous ? _fbb.CreateString(previous) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto work__ = work ? _fbb.CreateString(work) : 0;
  return futureheadapi::CreateBlockReceive(
      _fbb,
      hash__,
      previous__,
      source__,
      signature__,
      work__);
}

flatbuffers::Offset<BlockReceive> CreateBlockReceive(flatbuffers::FlatBufferBuilder &_fbb, const BlockReceiveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockSendT : public flatbuffers::NativeTable {
  typedef BlockSend TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockSendT";
  }
  std::string hash;
  std::string previous;
  std::string destination;
  std::string balance;
  std::string signature;
  std::string work;
  BlockSendT() {
  }
};

struct BlockSend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockSendT NativeTableType;
  typedef BlockSendBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockSendTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockSend";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_PREVIOUS = 6,
    VT_DESTINATION = 8,
    VT_BALANCE = 10,
    VT_SIGNATURE = 12,
    VT_WORK = 14
  };
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *previous() const {
    return GetPointer<const flatbuffers::String *>(VT_PREVIOUS);
  }
  flatbuffers::String *mutable_previous() {
    return GetPointer<flatbuffers::String *>(VT_PREVIOUS);
  }
  const flatbuffers::String *destination() const {
    return GetPointer<const flatbuffers::String *>(VT_DESTINATION);
  }
  flatbuffers::String *mutable_destination() {
    return GetPointer<flatbuffers::String *>(VT_DESTINATION);
  }
  const flatbuffers::String *balance() const {
    return GetPointer<const flatbuffers::String *>(VT_BALANCE);
  }
  flatbuffers::String *mutable_balance() {
    return GetPointer<flatbuffers::String *>(VT_BALANCE);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  flatbuffers::String *mutable_signature() {
    return GetPointer<flatbuffers::String *>(VT_SIGNATURE);
  }
  const flatbuffers::String *work() const {
    return GetPointer<const flatbuffers::String *>(VT_WORK);
  }
  flatbuffers::String *mutable_work() {
    return GetPointer<flatbuffers::String *>(VT_WORK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyString(previous()) &&
           VerifyOffset(verifier, VT_DESTINATION) &&
           verifier.VerifyString(destination()) &&
           VerifyOffset(verifier, VT_BALANCE) &&
           verifier.VerifyString(balance()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_WORK) &&
           verifier.VerifyString(work()) &&
           verifier.EndTable();
  }
  BlockSendT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockSendT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockSend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockSendT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockSendBuilder {
  typedef BlockSend Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(BlockSend::VT_HASH, hash);
  }
  void add_previous(flatbuffers::Offset<flatbuffers::String> previous) {
    fbb_.AddOffset(BlockSend::VT_PREVIOUS, previous);
  }
  void add_destination(flatbuffers::Offset<flatbuffers::String> destination) {
    fbb_.AddOffset(BlockSend::VT_DESTINATION, destination);
  }
  void add_balance(flatbuffers::Offset<flatbuffers::String> balance) {
    fbb_.AddOffset(BlockSend::VT_BALANCE, balance);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(BlockSend::VT_SIGNATURE, signature);
  }
  void add_work(flatbuffers::Offset<flatbuffers::String> work) {
    fbb_.AddOffset(BlockSend::VT_WORK, work);
  }
  explicit BlockSendBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockSendBuilder &operator=(const BlockSendBuilder &);
  flatbuffers::Offset<BlockSend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockSend>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockSend> CreateBlockSend(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> previous = 0,
    flatbuffers::Offset<flatbuffers::String> destination = 0,
    flatbuffers::Offset<flatbuffers::String> balance = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    flatbuffers::Offset<flatbuffers::String> work = 0) {
  BlockSendBuilder builder_(_fbb);
  builder_.add_work(work);
  builder_.add_signature(signature);
  builder_.add_balance(balance);
  builder_.add_destination(destination);
  builder_.add_previous(previous);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockSend> CreateBlockSendDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hash = nullptr,
    const char *previous = nullptr,
    const char *destination = nullptr,
    const char *balance = nullptr,
    const char *signature = nullptr,
    const char *work = nullptr) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto previous__ = previous ? _fbb.CreateString(previous) : 0;
  auto destination__ = destination ? _fbb.CreateString(destination) : 0;
  auto balance__ = balance ? _fbb.CreateString(balance) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto work__ = work ? _fbb.CreateString(work) : 0;
  return futureheadapi::CreateBlockSend(
      _fbb,
      hash__,
      previous__,
      destination__,
      balance__,
      signature__,
      work__);
}

flatbuffers::Offset<BlockSend> CreateBlockSend(flatbuffers::FlatBufferBuilder &_fbb, const BlockSendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockChangeT : public flatbuffers::NativeTable {
  typedef BlockChange TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockChangeT";
  }
  std::string hash;
  std::string previous;
  std::string representative;
  std::string signature;
  std::string work;
  BlockChangeT() {
  }
};

struct BlockChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockChangeT NativeTableType;
  typedef BlockChangeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockChangeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockChange";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_PREVIOUS = 6,
    VT_REPRESENTATIVE = 8,
    VT_SIGNATURE = 10,
    VT_WORK = 12
  };
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *previous() const {
    return GetPointer<const flatbuffers::String *>(VT_PREVIOUS);
  }
  flatbuffers::String *mutable_previous() {
    return GetPointer<flatbuffers::String *>(VT_PREVIOUS);
  }
  const flatbuffers::String *representative() const {
    return GetPointer<const flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  flatbuffers::String *mutable_representative() {
    return GetPointer<flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  flatbuffers::String *mutable_signature() {
    return GetPointer<flatbuffers::String *>(VT_SIGNATURE);
  }
  const flatbuffers::String *work() const {
    return GetPointer<const flatbuffers::String *>(VT_WORK);
  }
  flatbuffers::String *mutable_work() {
    return GetPointer<flatbuffers::String *>(VT_WORK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyString(previous()) &&
           VerifyOffset(verifier, VT_REPRESENTATIVE) &&
           verifier.VerifyString(representative()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_WORK) &&
           verifier.VerifyString(work()) &&
           verifier.EndTable();
  }
  BlockChangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockChangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockChange> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockChangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockChangeBuilder {
  typedef BlockChange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(BlockChange::VT_HASH, hash);
  }
  void add_previous(flatbuffers::Offset<flatbuffers::String> previous) {
    fbb_.AddOffset(BlockChange::VT_PREVIOUS, previous);
  }
  void add_representative(flatbuffers::Offset<flatbuffers::String> representative) {
    fbb_.AddOffset(BlockChange::VT_REPRESENTATIVE, representative);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(BlockChange::VT_SIGNATURE, signature);
  }
  void add_work(flatbuffers::Offset<flatbuffers::String> work) {
    fbb_.AddOffset(BlockChange::VT_WORK, work);
  }
  explicit BlockChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockChangeBuilder &operator=(const BlockChangeBuilder &);
  flatbuffers::Offset<BlockChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockChange>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockChange> CreateBlockChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> previous = 0,
    flatbuffers::Offset<flatbuffers::String> representative = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    flatbuffers::Offset<flatbuffers::String> work = 0) {
  BlockChangeBuilder builder_(_fbb);
  builder_.add_work(work);
  builder_.add_signature(signature);
  builder_.add_representative(representative);
  builder_.add_previous(previous);
  builder_.add_hash(hash);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockChange> CreateBlockChangeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hash = nullptr,
    const char *previous = nullptr,
    const char *representative = nullptr,
    const char *signature = nullptr,
    const char *work = nullptr) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto previous__ = previous ? _fbb.CreateString(previous) : 0;
  auto representative__ = representative ? _fbb.CreateString(representative) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto work__ = work ? _fbb.CreateString(work) : 0;
  return futureheadapi::CreateBlockChange(
      _fbb,
      hash__,
      previous__,
      representative__,
      signature__,
      work__);
}

flatbuffers::Offset<BlockChange> CreateBlockChange(flatbuffers::FlatBufferBuilder &_fbb, const BlockChangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockStateT : public flatbuffers::NativeTable {
  typedef BlockState TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockStateT";
  }
  std::string hash;
  std::string account;
  std::string previous;
  std::string representative;
  std::string balance;
  std::string link;
  std::string link_as_account;
  std::string signature;
  std::string work;
  futureheadapi::BlockSubType subtype;
  BlockStateT()
      : subtype(futureheadapi::BlockSubType_invalid) {
  }
};

struct BlockState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockStateT NativeTableType;
  typedef BlockStateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockStateTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockState";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_ACCOUNT = 6,
    VT_PREVIOUS = 8,
    VT_REPRESENTATIVE = 10,
    VT_BALANCE = 12,
    VT_LINK = 14,
    VT_LINK_AS_ACCOUNT = 16,
    VT_SIGNATURE = 18,
    VT_WORK = 20,
    VT_SUBTYPE = 22
  };
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *previous() const {
    return GetPointer<const flatbuffers::String *>(VT_PREVIOUS);
  }
  flatbuffers::String *mutable_previous() {
    return GetPointer<flatbuffers::String *>(VT_PREVIOUS);
  }
  const flatbuffers::String *representative() const {
    return GetPointer<const flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  flatbuffers::String *mutable_representative() {
    return GetPointer<flatbuffers::String *>(VT_REPRESENTATIVE);
  }
  const flatbuffers::String *balance() const {
    return GetPointer<const flatbuffers::String *>(VT_BALANCE);
  }
  flatbuffers::String *mutable_balance() {
    return GetPointer<flatbuffers::String *>(VT_BALANCE);
  }
  const flatbuffers::String *link() const {
    return GetPointer<const flatbuffers::String *>(VT_LINK);
  }
  flatbuffers::String *mutable_link() {
    return GetPointer<flatbuffers::String *>(VT_LINK);
  }
  const flatbuffers::String *link_as_account() const {
    return GetPointer<const flatbuffers::String *>(VT_LINK_AS_ACCOUNT);
  }
  flatbuffers::String *mutable_link_as_account() {
    return GetPointer<flatbuffers::String *>(VT_LINK_AS_ACCOUNT);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  flatbuffers::String *mutable_signature() {
    return GetPointer<flatbuffers::String *>(VT_SIGNATURE);
  }
  const flatbuffers::String *work() const {
    return GetPointer<const flatbuffers::String *>(VT_WORK);
  }
  flatbuffers::String *mutable_work() {
    return GetPointer<flatbuffers::String *>(VT_WORK);
  }
  futureheadapi::BlockSubType subtype() const {
    return static_cast<futureheadapi::BlockSubType>(GetField<int8_t>(VT_SUBTYPE, 0));
  }
  bool mutate_subtype(futureheadapi::BlockSubType _subtype) {
    return SetField<int8_t>(VT_SUBTYPE, static_cast<int8_t>(_subtype), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_PREVIOUS) &&
           verifier.VerifyString(previous()) &&
           VerifyOffset(verifier, VT_REPRESENTATIVE) &&
           verifier.VerifyString(representative()) &&
           VerifyOffset(verifier, VT_BALANCE) &&
           verifier.VerifyString(balance()) &&
           VerifyOffset(verifier, VT_LINK) &&
           verifier.VerifyString(link()) &&
           VerifyOffset(verifier, VT_LINK_AS_ACCOUNT) &&
           verifier.VerifyString(link_as_account()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_WORK) &&
           verifier.VerifyString(work()) &&
           VerifyField<int8_t>(verifier, VT_SUBTYPE) &&
           verifier.EndTable();
  }
  BlockStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockStateBuilder {
  typedef BlockState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(BlockState::VT_HASH, hash);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(BlockState::VT_ACCOUNT, account);
  }
  void add_previous(flatbuffers::Offset<flatbuffers::String> previous) {
    fbb_.AddOffset(BlockState::VT_PREVIOUS, previous);
  }
  void add_representative(flatbuffers::Offset<flatbuffers::String> representative) {
    fbb_.AddOffset(BlockState::VT_REPRESENTATIVE, representative);
  }
  void add_balance(flatbuffers::Offset<flatbuffers::String> balance) {
    fbb_.AddOffset(BlockState::VT_BALANCE, balance);
  }
  void add_link(flatbuffers::Offset<flatbuffers::String> link) {
    fbb_.AddOffset(BlockState::VT_LINK, link);
  }
  void add_link_as_account(flatbuffers::Offset<flatbuffers::String> link_as_account) {
    fbb_.AddOffset(BlockState::VT_LINK_AS_ACCOUNT, link_as_account);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(BlockState::VT_SIGNATURE, signature);
  }
  void add_work(flatbuffers::Offset<flatbuffers::String> work) {
    fbb_.AddOffset(BlockState::VT_WORK, work);
  }
  void add_subtype(futureheadapi::BlockSubType subtype) {
    fbb_.AddElement<int8_t>(BlockState::VT_SUBTYPE, static_cast<int8_t>(subtype), 0);
  }
  explicit BlockStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockStateBuilder &operator=(const BlockStateBuilder &);
  flatbuffers::Offset<BlockState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockState>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockState> CreateBlockState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> previous = 0,
    flatbuffers::Offset<flatbuffers::String> representative = 0,
    flatbuffers::Offset<flatbuffers::String> balance = 0,
    flatbuffers::Offset<flatbuffers::String> link = 0,
    flatbuffers::Offset<flatbuffers::String> link_as_account = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0,
    flatbuffers::Offset<flatbuffers::String> work = 0,
    futureheadapi::BlockSubType subtype = futureheadapi::BlockSubType_invalid) {
  BlockStateBuilder builder_(_fbb);
  builder_.add_work(work);
  builder_.add_signature(signature);
  builder_.add_link_as_account(link_as_account);
  builder_.add_link(link);
  builder_.add_balance(balance);
  builder_.add_representative(representative);
  builder_.add_previous(previous);
  builder_.add_account(account);
  builder_.add_hash(hash);
  builder_.add_subtype(subtype);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockState> CreateBlockStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hash = nullptr,
    const char *account = nullptr,
    const char *previous = nullptr,
    const char *representative = nullptr,
    const char *balance = nullptr,
    const char *link = nullptr,
    const char *link_as_account = nullptr,
    const char *signature = nullptr,
    const char *work = nullptr,
    futureheadapi::BlockSubType subtype = futureheadapi::BlockSubType_invalid) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto previous__ = previous ? _fbb.CreateString(previous) : 0;
  auto representative__ = representative ? _fbb.CreateString(representative) : 0;
  auto balance__ = balance ? _fbb.CreateString(balance) : 0;
  auto link__ = link ? _fbb.CreateString(link) : 0;
  auto link_as_account__ = link_as_account ? _fbb.CreateString(link_as_account) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto work__ = work ? _fbb.CreateString(work) : 0;
  return futureheadapi::CreateBlockState(
      _fbb,
      hash__,
      account__,
      previous__,
      representative__,
      balance__,
      link__,
      link_as_account__,
      signature__,
      work__,
      subtype);
}

flatbuffers::Offset<BlockState> CreateBlockState(flatbuffers::FlatBufferBuilder &_fbb, const BlockStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockInfoT : public flatbuffers::NativeTable {
  typedef BlockInfo TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockInfoT";
  }
  futureheadapi::BlockUnion block;
  BlockInfoT() {
  }
};

struct BlockInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockInfoT NativeTableType;
  typedef BlockInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.BlockInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_TYPE = 4,
    VT_BLOCK = 6
  };
  futureheadapi::Block block_type() const {
    return static_cast<futureheadapi::Block>(GetField<uint8_t>(VT_BLOCK_TYPE, 0));
  }
  const void *block() const {
    return GetPointer<const void *>(VT_BLOCK);
  }
  template<typename T> const T *block_as() const;
  const futureheadapi::BlockState *block_as_BlockState() const {
    return block_type() == futureheadapi::Block_BlockState ? static_cast<const futureheadapi::BlockState *>(block()) : nullptr;
  }
  const futureheadapi::BlockOpen *block_as_BlockOpen() const {
    return block_type() == futureheadapi::Block_BlockOpen ? static_cast<const futureheadapi::BlockOpen *>(block()) : nullptr;
  }
  const futureheadapi::BlockReceive *block_as_BlockReceive() const {
    return block_type() == futureheadapi::Block_BlockReceive ? static_cast<const futureheadapi::BlockReceive *>(block()) : nullptr;
  }
  const futureheadapi::BlockSend *block_as_BlockSend() const {
    return block_type() == futureheadapi::Block_BlockSend ? static_cast<const futureheadapi::BlockSend *>(block()) : nullptr;
  }
  const futureheadapi::BlockChange *block_as_BlockChange() const {
    return block_type() == futureheadapi::Block_BlockChange ? static_cast<const futureheadapi::BlockChange *>(block()) : nullptr;
  }
  void *mutable_block() {
    return GetPointer<void *>(VT_BLOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BLOCK_TYPE) &&
           VerifyOffset(verifier, VT_BLOCK) &&
           VerifyBlock(verifier, block(), block_type()) &&
           verifier.EndTable();
  }
  BlockInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const futureheadapi::BlockState *BlockInfo::block_as<futureheadapi::BlockState>() const {
  return block_as_BlockState();
}

template<> inline const futureheadapi::BlockOpen *BlockInfo::block_as<futureheadapi::BlockOpen>() const {
  return block_as_BlockOpen();
}

template<> inline const futureheadapi::BlockReceive *BlockInfo::block_as<futureheadapi::BlockReceive>() const {
  return block_as_BlockReceive();
}

template<> inline const futureheadapi::BlockSend *BlockInfo::block_as<futureheadapi::BlockSend>() const {
  return block_as_BlockSend();
}

template<> inline const futureheadapi::BlockChange *BlockInfo::block_as<futureheadapi::BlockChange>() const {
  return block_as_BlockChange();
}

struct BlockInfoBuilder {
  typedef BlockInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_type(futureheadapi::Block block_type) {
    fbb_.AddElement<uint8_t>(BlockInfo::VT_BLOCK_TYPE, static_cast<uint8_t>(block_type), 0);
  }
  void add_block(flatbuffers::Offset<void> block) {
    fbb_.AddOffset(BlockInfo::VT_BLOCK, block);
  }
  explicit BlockInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockInfoBuilder &operator=(const BlockInfoBuilder &);
  flatbuffers::Offset<BlockInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockInfo> CreateBlockInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    futureheadapi::Block block_type = futureheadapi::Block_NONE,
    flatbuffers::Offset<void> block = 0) {
  BlockInfoBuilder builder_(_fbb);
  builder_.add_block(block);
  builder_.add_block_type(block_type);
  return builder_.Finish();
}

flatbuffers::Offset<BlockInfo> CreateBlockInfo(flatbuffers::FlatBufferBuilder &_fbb, const BlockInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServiceRegisterT : public flatbuffers::NativeTable {
  typedef ServiceRegister TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ServiceRegisterT";
  }
  std::string service_name;
  ServiceRegisterT() {
  }
};

struct ServiceRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceRegisterT NativeTableType;
  typedef ServiceRegisterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServiceRegisterTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ServiceRegister";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVICE_NAME = 4
  };
  const flatbuffers::String *service_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVICE_NAME);
  }
  flatbuffers::String *mutable_service_name() {
    return GetPointer<flatbuffers::String *>(VT_SERVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVICE_NAME) &&
           verifier.VerifyString(service_name()) &&
           verifier.EndTable();
  }
  ServiceRegisterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServiceRegisterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServiceRegister> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceRegisterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServiceRegisterBuilder {
  typedef ServiceRegister Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_service_name(flatbuffers::Offset<flatbuffers::String> service_name) {
    fbb_.AddOffset(ServiceRegister::VT_SERVICE_NAME, service_name);
  }
  explicit ServiceRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceRegisterBuilder &operator=(const ServiceRegisterBuilder &);
  flatbuffers::Offset<ServiceRegister> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceRegister>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServiceRegister> CreateServiceRegister(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> service_name = 0) {
  ServiceRegisterBuilder builder_(_fbb);
  builder_.add_service_name(service_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServiceRegister> CreateServiceRegisterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *service_name = nullptr) {
  auto service_name__ = service_name ? _fbb.CreateString(service_name) : 0;
  return futureheadapi::CreateServiceRegister(
      _fbb,
      service_name__);
}

flatbuffers::Offset<ServiceRegister> CreateServiceRegister(flatbuffers::FlatBufferBuilder &_fbb, const ServiceRegisterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServiceStopT : public flatbuffers::NativeTable {
  typedef ServiceStop TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ServiceStopT";
  }
  std::string service_name;
  bool restart;
  ServiceStopT()
      : restart(false) {
  }
};

struct ServiceStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceStopT NativeTableType;
  typedef ServiceStopBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServiceStopTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ServiceStop";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVICE_NAME = 4,
    VT_RESTART = 6
  };
  const flatbuffers::String *service_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVICE_NAME);
  }
  flatbuffers::String *mutable_service_name() {
    return GetPointer<flatbuffers::String *>(VT_SERVICE_NAME);
  }
  bool restart() const {
    return GetField<uint8_t>(VT_RESTART, 0) != 0;
  }
  bool mutate_restart(bool _restart) {
    return SetField<uint8_t>(VT_RESTART, static_cast<uint8_t>(_restart), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SERVICE_NAME) &&
           verifier.VerifyString(service_name()) &&
           VerifyField<uint8_t>(verifier, VT_RESTART) &&
           verifier.EndTable();
  }
  ServiceStopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServiceStop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServiceStopBuilder {
  typedef ServiceStop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_service_name(flatbuffers::Offset<flatbuffers::String> service_name) {
    fbb_.AddOffset(ServiceStop::VT_SERVICE_NAME, service_name);
  }
  void add_restart(bool restart) {
    fbb_.AddElement<uint8_t>(ServiceStop::VT_RESTART, static_cast<uint8_t>(restart), 0);
  }
  explicit ServiceStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceStopBuilder &operator=(const ServiceStopBuilder &);
  flatbuffers::Offset<ServiceStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceStop>(end);
    fbb_.Required(o, ServiceStop::VT_SERVICE_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ServiceStop> CreateServiceStop(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> service_name = 0,
    bool restart = false) {
  ServiceStopBuilder builder_(_fbb);
  builder_.add_service_name(service_name);
  builder_.add_restart(restart);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServiceStop> CreateServiceStopDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *service_name = nullptr,
    bool restart = false) {
  auto service_name__ = service_name ? _fbb.CreateString(service_name) : 0;
  return futureheadapi::CreateServiceStop(
      _fbb,
      service_name__,
      restart);
}

flatbuffers::Offset<ServiceStop> CreateServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const ServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopicServiceStopT : public flatbuffers::NativeTable {
  typedef TopicServiceStop TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicServiceStopT";
  }
  bool unsubscribe;
  TopicServiceStopT()
      : unsubscribe(false) {
  }
};

struct TopicServiceStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicServiceStopT NativeTableType;
  typedef TopicServiceStopBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopicServiceStopTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicServiceStop";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNSUBSCRIBE = 4
  };
  bool unsubscribe() const {
    return GetField<uint8_t>(VT_UNSUBSCRIBE, 0) != 0;
  }
  bool mutate_unsubscribe(bool _unsubscribe) {
    return SetField<uint8_t>(VT_UNSUBSCRIBE, static_cast<uint8_t>(_unsubscribe), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNSUBSCRIBE) &&
           verifier.EndTable();
  }
  TopicServiceStopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopicServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopicServiceStop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopicServiceStopBuilder {
  typedef TopicServiceStop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unsubscribe(bool unsubscribe) {
    fbb_.AddElement<uint8_t>(TopicServiceStop::VT_UNSUBSCRIBE, static_cast<uint8_t>(unsubscribe), 0);
  }
  explicit TopicServiceStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicServiceStopBuilder &operator=(const TopicServiceStopBuilder &);
  flatbuffers::Offset<TopicServiceStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicServiceStop>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicServiceStop> CreateTopicServiceStop(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool unsubscribe = false) {
  TopicServiceStopBuilder builder_(_fbb);
  builder_.add_unsubscribe(unsubscribe);
  return builder_.Finish();
}

flatbuffers::Offset<TopicServiceStop> CreateTopicServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const TopicServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventServiceStopT : public flatbuffers::NativeTable {
  typedef EventServiceStop TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventServiceStopT";
  }
  EventServiceStopT() {
  }
};

struct EventServiceStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventServiceStopT NativeTableType;
  typedef EventServiceStopBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventServiceStopTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventServiceStop";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EventServiceStopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventServiceStop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventServiceStopBuilder {
  typedef EventServiceStop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EventServiceStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventServiceStopBuilder &operator=(const EventServiceStopBuilder &);
  flatbuffers::Offset<EventServiceStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventServiceStop>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventServiceStop> CreateEventServiceStop(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EventServiceStopBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EventServiceStop> CreateEventServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const EventServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventAckT : public flatbuffers::NativeTable {
  typedef EventAck TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventAckT";
  }
  EventAckT() {
  }
};

struct EventAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventAckT NativeTableType;
  typedef EventAckBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventAckTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventAck";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EventAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventAckT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventAckBuilder {
  typedef EventAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EventAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventAckBuilder &operator=(const EventAckBuilder &);
  flatbuffers::Offset<EventAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventAck> CreateEventAck(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EventAckBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EventAck> CreateEventAck(flatbuffers::FlatBufferBuilder &_fbb, const EventAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopicConfirmationT : public flatbuffers::NativeTable {
  typedef TopicConfirmation TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicConfirmationT";
  }
  bool unsubscribe;
  std::unique_ptr<futureheadapi::TopicConfirmationOptionsT> options;
  TopicConfirmationT()
      : unsubscribe(false) {
  }
};

struct TopicConfirmation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicConfirmationT NativeTableType;
  typedef TopicConfirmationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopicConfirmationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicConfirmation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNSUBSCRIBE = 4,
    VT_OPTIONS = 6
  };
  bool unsubscribe() const {
    return GetField<uint8_t>(VT_UNSUBSCRIBE, 0) != 0;
  }
  bool mutate_unsubscribe(bool _unsubscribe) {
    return SetField<uint8_t>(VT_UNSUBSCRIBE, static_cast<uint8_t>(_unsubscribe), 0);
  }
  const futureheadapi::TopicConfirmationOptions *options() const {
    return GetPointer<const futureheadapi::TopicConfirmationOptions *>(VT_OPTIONS);
  }
  futureheadapi::TopicConfirmationOptions *mutable_options() {
    return GetPointer<futureheadapi::TopicConfirmationOptions *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNSUBSCRIBE) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           verifier.EndTable();
  }
  TopicConfirmationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopicConfirmationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopicConfirmation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopicConfirmationBuilder {
  typedef TopicConfirmation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unsubscribe(bool unsubscribe) {
    fbb_.AddElement<uint8_t>(TopicConfirmation::VT_UNSUBSCRIBE, static_cast<uint8_t>(unsubscribe), 0);
  }
  void add_options(flatbuffers::Offset<futureheadapi::TopicConfirmationOptions> options) {
    fbb_.AddOffset(TopicConfirmation::VT_OPTIONS, options);
  }
  explicit TopicConfirmationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicConfirmationBuilder &operator=(const TopicConfirmationBuilder &);
  flatbuffers::Offset<TopicConfirmation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicConfirmation>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicConfirmation> CreateTopicConfirmation(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool unsubscribe = false,
    flatbuffers::Offset<futureheadapi::TopicConfirmationOptions> options = 0) {
  TopicConfirmationBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_unsubscribe(unsubscribe);
  return builder_.Finish();
}

flatbuffers::Offset<TopicConfirmation> CreateTopicConfirmation(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopicConfirmationOptionsT : public flatbuffers::NativeTable {
  typedef TopicConfirmationOptions TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicConfirmationOptionsT";
  }
  futureheadapi::TopicConfirmationTypeFilter confirmation_type_filter;
  bool all_local_accounts;
  std::vector<std::string> accounts;
  bool include_block;
  bool include_election_info;
  TopicConfirmationOptionsT()
      : confirmation_type_filter(futureheadapi::TopicConfirmationTypeFilter_all),
        all_local_accounts(false),
        include_block(true),
        include_election_info(true) {
  }
};

struct TopicConfirmationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicConfirmationOptionsT NativeTableType;
  typedef TopicConfirmationOptionsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopicConfirmationOptionsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.TopicConfirmationOptions";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIRMATION_TYPE_FILTER = 4,
    VT_ALL_LOCAL_ACCOUNTS = 6,
    VT_ACCOUNTS = 8,
    VT_INCLUDE_BLOCK = 10,
    VT_INCLUDE_ELECTION_INFO = 12
  };
  futureheadapi::TopicConfirmationTypeFilter confirmation_type_filter() const {
    return static_cast<futureheadapi::TopicConfirmationTypeFilter>(GetField<int8_t>(VT_CONFIRMATION_TYPE_FILTER, 0));
  }
  bool mutate_confirmation_type_filter(futureheadapi::TopicConfirmationTypeFilter _confirmation_type_filter) {
    return SetField<int8_t>(VT_CONFIRMATION_TYPE_FILTER, static_cast<int8_t>(_confirmation_type_filter), 0);
  }
  bool all_local_accounts() const {
    return GetField<uint8_t>(VT_ALL_LOCAL_ACCOUNTS, 0) != 0;
  }
  bool mutate_all_local_accounts(bool _all_local_accounts) {
    return SetField<uint8_t>(VT_ALL_LOCAL_ACCOUNTS, static_cast<uint8_t>(_all_local_accounts), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACCOUNTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_accounts() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACCOUNTS);
  }
  bool include_block() const {
    return GetField<uint8_t>(VT_INCLUDE_BLOCK, 1) != 0;
  }
  bool mutate_include_block(bool _include_block) {
    return SetField<uint8_t>(VT_INCLUDE_BLOCK, static_cast<uint8_t>(_include_block), 1);
  }
  bool include_election_info() const {
    return GetField<uint8_t>(VT_INCLUDE_ELECTION_INFO, 1) != 0;
  }
  bool mutate_include_election_info(bool _include_election_info) {
    return SetField<uint8_t>(VT_INCLUDE_ELECTION_INFO, static_cast<uint8_t>(_include_election_info), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CONFIRMATION_TYPE_FILTER) &&
           VerifyField<uint8_t>(verifier, VT_ALL_LOCAL_ACCOUNTS) &&
           VerifyOffset(verifier, VT_ACCOUNTS) &&
           verifier.VerifyVector(accounts()) &&
           verifier.VerifyVectorOfStrings(accounts()) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_BLOCK) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ELECTION_INFO) &&
           verifier.EndTable();
  }
  TopicConfirmationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopicConfirmationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopicConfirmationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopicConfirmationOptionsBuilder {
  typedef TopicConfirmationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_confirmation_type_filter(futureheadapi::TopicConfirmationTypeFilter confirmation_type_filter) {
    fbb_.AddElement<int8_t>(TopicConfirmationOptions::VT_CONFIRMATION_TYPE_FILTER, static_cast<int8_t>(confirmation_type_filter), 0);
  }
  void add_all_local_accounts(bool all_local_accounts) {
    fbb_.AddElement<uint8_t>(TopicConfirmationOptions::VT_ALL_LOCAL_ACCOUNTS, static_cast<uint8_t>(all_local_accounts), 0);
  }
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts) {
    fbb_.AddOffset(TopicConfirmationOptions::VT_ACCOUNTS, accounts);
  }
  void add_include_block(bool include_block) {
    fbb_.AddElement<uint8_t>(TopicConfirmationOptions::VT_INCLUDE_BLOCK, static_cast<uint8_t>(include_block), 1);
  }
  void add_include_election_info(bool include_election_info) {
    fbb_.AddElement<uint8_t>(TopicConfirmationOptions::VT_INCLUDE_ELECTION_INFO, static_cast<uint8_t>(include_election_info), 1);
  }
  explicit TopicConfirmationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicConfirmationOptionsBuilder &operator=(const TopicConfirmationOptionsBuilder &);
  flatbuffers::Offset<TopicConfirmationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicConfirmationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicConfirmationOptions> CreateTopicConfirmationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    futureheadapi::TopicConfirmationTypeFilter confirmation_type_filter = futureheadapi::TopicConfirmationTypeFilter_all,
    bool all_local_accounts = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts = 0,
    bool include_block = true,
    bool include_election_info = true) {
  TopicConfirmationOptionsBuilder builder_(_fbb);
  builder_.add_accounts(accounts);
  builder_.add_include_election_info(include_election_info);
  builder_.add_include_block(include_block);
  builder_.add_all_local_accounts(all_local_accounts);
  builder_.add_confirmation_type_filter(confirmation_type_filter);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopicConfirmationOptions> CreateTopicConfirmationOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    futureheadapi::TopicConfirmationTypeFilter confirmation_type_filter = futureheadapi::TopicConfirmationTypeFilter_all,
    bool all_local_accounts = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *accounts = nullptr,
    bool include_block = true,
    bool include_election_info = true) {
  auto accounts__ = accounts ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*accounts) : 0;
  return futureheadapi::CreateTopicConfirmationOptions(
      _fbb,
      confirmation_type_filter,
      all_local_accounts,
      accounts__,
      include_block,
      include_election_info);
}

flatbuffers::Offset<TopicConfirmationOptions> CreateTopicConfirmationOptions(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventConfirmationT : public flatbuffers::NativeTable {
  typedef EventConfirmation TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventConfirmationT";
  }
  futureheadapi::TopicConfirmationType confirmation_type;
  std::string account;
  std::string amount;
  std::string hash;
  futureheadapi::BlockUnion block;
  std::unique_ptr<futureheadapi::ElectionInfoT> election_info;
  EventConfirmationT()
      : confirmation_type(futureheadapi::TopicConfirmationType_active_quorum) {
  }
};

struct EventConfirmation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventConfirmationT NativeTableType;
  typedef EventConfirmationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventConfirmationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EventConfirmation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIRMATION_TYPE = 4,
    VT_ACCOUNT = 6,
    VT_AMOUNT = 8,
    VT_HASH = 10,
    VT_BLOCK_TYPE = 12,
    VT_BLOCK = 14,
    VT_ELECTION_INFO = 16
  };
  futureheadapi::TopicConfirmationType confirmation_type() const {
    return static_cast<futureheadapi::TopicConfirmationType>(GetField<int8_t>(VT_CONFIRMATION_TYPE, 0));
  }
  bool mutate_confirmation_type(futureheadapi::TopicConfirmationType _confirmation_type) {
    return SetField<int8_t>(VT_CONFIRMATION_TYPE, static_cast<int8_t>(_confirmation_type), 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *amount() const {
    return GetPointer<const flatbuffers::String *>(VT_AMOUNT);
  }
  flatbuffers::String *mutable_amount() {
    return GetPointer<flatbuffers::String *>(VT_AMOUNT);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  flatbuffers::String *mutable_hash() {
    return GetPointer<flatbuffers::String *>(VT_HASH);
  }
  futureheadapi::Block block_type() const {
    return static_cast<futureheadapi::Block>(GetField<uint8_t>(VT_BLOCK_TYPE, 0));
  }
  const void *block() const {
    return GetPointer<const void *>(VT_BLOCK);
  }
  template<typename T> const T *block_as() const;
  const futureheadapi::BlockState *block_as_BlockState() const {
    return block_type() == futureheadapi::Block_BlockState ? static_cast<const futureheadapi::BlockState *>(block()) : nullptr;
  }
  const futureheadapi::BlockOpen *block_as_BlockOpen() const {
    return block_type() == futureheadapi::Block_BlockOpen ? static_cast<const futureheadapi::BlockOpen *>(block()) : nullptr;
  }
  const futureheadapi::BlockReceive *block_as_BlockReceive() const {
    return block_type() == futureheadapi::Block_BlockReceive ? static_cast<const futureheadapi::BlockReceive *>(block()) : nullptr;
  }
  const futureheadapi::BlockSend *block_as_BlockSend() const {
    return block_type() == futureheadapi::Block_BlockSend ? static_cast<const futureheadapi::BlockSend *>(block()) : nullptr;
  }
  const futureheadapi::BlockChange *block_as_BlockChange() const {
    return block_type() == futureheadapi::Block_BlockChange ? static_cast<const futureheadapi::BlockChange *>(block()) : nullptr;
  }
  void *mutable_block() {
    return GetPointer<void *>(VT_BLOCK);
  }
  const futureheadapi::ElectionInfo *election_info() const {
    return GetPointer<const futureheadapi::ElectionInfo *>(VT_ELECTION_INFO);
  }
  futureheadapi::ElectionInfo *mutable_election_info() {
    return GetPointer<futureheadapi::ElectionInfo *>(VT_ELECTION_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CONFIRMATION_TYPE) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_AMOUNT) &&
           verifier.VerifyString(amount()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyField<uint8_t>(verifier, VT_BLOCK_TYPE) &&
           VerifyOffset(verifier, VT_BLOCK) &&
           VerifyBlock(verifier, block(), block_type()) &&
           VerifyOffset(verifier, VT_ELECTION_INFO) &&
           verifier.VerifyTable(election_info()) &&
           verifier.EndTable();
  }
  EventConfirmationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventConfirmationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventConfirmation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventConfirmationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const futureheadapi::BlockState *EventConfirmation::block_as<futureheadapi::BlockState>() const {
  return block_as_BlockState();
}

template<> inline const futureheadapi::BlockOpen *EventConfirmation::block_as<futureheadapi::BlockOpen>() const {
  return block_as_BlockOpen();
}

template<> inline const futureheadapi::BlockReceive *EventConfirmation::block_as<futureheadapi::BlockReceive>() const {
  return block_as_BlockReceive();
}

template<> inline const futureheadapi::BlockSend *EventConfirmation::block_as<futureheadapi::BlockSend>() const {
  return block_as_BlockSend();
}

template<> inline const futureheadapi::BlockChange *EventConfirmation::block_as<futureheadapi::BlockChange>() const {
  return block_as_BlockChange();
}

struct EventConfirmationBuilder {
  typedef EventConfirmation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_confirmation_type(futureheadapi::TopicConfirmationType confirmation_type) {
    fbb_.AddElement<int8_t>(EventConfirmation::VT_CONFIRMATION_TYPE, static_cast<int8_t>(confirmation_type), 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(EventConfirmation::VT_ACCOUNT, account);
  }
  void add_amount(flatbuffers::Offset<flatbuffers::String> amount) {
    fbb_.AddOffset(EventConfirmation::VT_AMOUNT, amount);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(EventConfirmation::VT_HASH, hash);
  }
  void add_block_type(futureheadapi::Block block_type) {
    fbb_.AddElement<uint8_t>(EventConfirmation::VT_BLOCK_TYPE, static_cast<uint8_t>(block_type), 0);
  }
  void add_block(flatbuffers::Offset<void> block) {
    fbb_.AddOffset(EventConfirmation::VT_BLOCK, block);
  }
  void add_election_info(flatbuffers::Offset<futureheadapi::ElectionInfo> election_info) {
    fbb_.AddOffset(EventConfirmation::VT_ELECTION_INFO, election_info);
  }
  explicit EventConfirmationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventConfirmationBuilder &operator=(const EventConfirmationBuilder &);
  flatbuffers::Offset<EventConfirmation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventConfirmation>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventConfirmation> CreateEventConfirmation(
    flatbuffers::FlatBufferBuilder &_fbb,
    futureheadapi::TopicConfirmationType confirmation_type = futureheadapi::TopicConfirmationType_active_quorum,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> amount = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0,
    futureheadapi::Block block_type = futureheadapi::Block_NONE,
    flatbuffers::Offset<void> block = 0,
    flatbuffers::Offset<futureheadapi::ElectionInfo> election_info = 0) {
  EventConfirmationBuilder builder_(_fbb);
  builder_.add_election_info(election_info);
  builder_.add_block(block);
  builder_.add_hash(hash);
  builder_.add_amount(amount);
  builder_.add_account(account);
  builder_.add_block_type(block_type);
  builder_.add_confirmation_type(confirmation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventConfirmation> CreateEventConfirmationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    futureheadapi::TopicConfirmationType confirmation_type = futureheadapi::TopicConfirmationType_active_quorum,
    const char *account = nullptr,
    const char *amount = nullptr,
    const char *hash = nullptr,
    futureheadapi::Block block_type = futureheadapi::Block_NONE,
    flatbuffers::Offset<void> block = 0,
    flatbuffers::Offset<futureheadapi::ElectionInfo> election_info = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto amount__ = amount ? _fbb.CreateString(amount) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  return futureheadapi::CreateEventConfirmation(
      _fbb,
      confirmation_type,
      account__,
      amount__,
      hash__,
      block_type,
      block,
      election_info);
}

flatbuffers::Offset<EventConfirmation> CreateEventConfirmation(flatbuffers::FlatBufferBuilder &_fbb, const EventConfirmationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElectionInfoT : public flatbuffers::NativeTable {
  typedef ElectionInfo TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ElectionInfoT";
  }
  uint64_t duration;
  uint64_t time;
  std::string tally;
  uint64_t request_count;
  uint64_t block_count;
  uint64_t voter_count;
  ElectionInfoT()
      : duration(0),
        time(0),
        request_count(0),
        block_count(0),
        voter_count(0) {
  }
};

struct ElectionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElectionInfoT NativeTableType;
  typedef ElectionInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ElectionInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ElectionInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DURATION = 4,
    VT_TIME = 6,
    VT_TALLY = 8,
    VT_REQUEST_COUNT = 10,
    VT_BLOCK_COUNT = 12,
    VT_VOTER_COUNT = 14
  };
  uint64_t duration() const {
    return GetField<uint64_t>(VT_DURATION, 0);
  }
  bool mutate_duration(uint64_t _duration) {
    return SetField<uint64_t>(VT_DURATION, _duration, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::String *tally() const {
    return GetPointer<const flatbuffers::String *>(VT_TALLY);
  }
  flatbuffers::String *mutable_tally() {
    return GetPointer<flatbuffers::String *>(VT_TALLY);
  }
  uint64_t request_count() const {
    return GetField<uint64_t>(VT_REQUEST_COUNT, 0);
  }
  bool mutate_request_count(uint64_t _request_count) {
    return SetField<uint64_t>(VT_REQUEST_COUNT, _request_count, 0);
  }
  uint64_t block_count() const {
    return GetField<uint64_t>(VT_BLOCK_COUNT, 0);
  }
  bool mutate_block_count(uint64_t _block_count) {
    return SetField<uint64_t>(VT_BLOCK_COUNT, _block_count, 0);
  }
  uint64_t voter_count() const {
    return GetField<uint64_t>(VT_VOTER_COUNT, 0);
  }
  bool mutate_voter_count(uint64_t _voter_count) {
    return SetField<uint64_t>(VT_VOTER_COUNT, _voter_count, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_DURATION) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_TALLY) &&
           verifier.VerifyString(tally()) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_COUNT) &&
           VerifyField<uint64_t>(verifier, VT_BLOCK_COUNT) &&
           VerifyField<uint64_t>(verifier, VT_VOTER_COUNT) &&
           verifier.EndTable();
  }
  ElectionInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElectionInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ElectionInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElectionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElectionInfoBuilder {
  typedef ElectionInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_duration(uint64_t duration) {
    fbb_.AddElement<uint64_t>(ElectionInfo::VT_DURATION, duration, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ElectionInfo::VT_TIME, time, 0);
  }
  void add_tally(flatbuffers::Offset<flatbuffers::String> tally) {
    fbb_.AddOffset(ElectionInfo::VT_TALLY, tally);
  }
  void add_request_count(uint64_t request_count) {
    fbb_.AddElement<uint64_t>(ElectionInfo::VT_REQUEST_COUNT, request_count, 0);
  }
  void add_block_count(uint64_t block_count) {
    fbb_.AddElement<uint64_t>(ElectionInfo::VT_BLOCK_COUNT, block_count, 0);
  }
  void add_voter_count(uint64_t voter_count) {
    fbb_.AddElement<uint64_t>(ElectionInfo::VT_VOTER_COUNT, voter_count, 0);
  }
  explicit ElectionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElectionInfoBuilder &operator=(const ElectionInfoBuilder &);
  flatbuffers::Offset<ElectionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElectionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElectionInfo> CreateElectionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t duration = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> tally = 0,
    uint64_t request_count = 0,
    uint64_t block_count = 0,
    uint64_t voter_count = 0) {
  ElectionInfoBuilder builder_(_fbb);
  builder_.add_voter_count(voter_count);
  builder_.add_block_count(block_count);
  builder_.add_request_count(request_count);
  builder_.add_time(time);
  builder_.add_duration(duration);
  builder_.add_tally(tally);
  return builder_.Finish();
}

inline flatbuffers::Offset<ElectionInfo> CreateElectionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t duration = 0,
    uint64_t time = 0,
    const char *tally = nullptr,
    uint64_t request_count = 0,
    uint64_t block_count = 0,
    uint64_t voter_count = 0) {
  auto tally__ = tally ? _fbb.CreateString(tally) : 0;
  return futureheadapi::CreateElectionInfo(
      _fbb,
      duration,
      time,
      tally__,
      request_count,
      block_count,
      voter_count);
}

flatbuffers::Offset<ElectionInfo> CreateElectionInfo(flatbuffers::FlatBufferBuilder &_fbb, const ElectionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.ErrorT";
  }
  int32_t code;
  int32_t category;
  std::string message;
  ErrorT()
      : code(0),
        category(0) {
  }
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ErrorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.Error";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_CATEGORY = 6,
    VT_MESSAGE = 8
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool mutate_code(int32_t _code) {
    return SetField<int32_t>(VT_CODE, _code, 0);
  }
  int32_t category() const {
    return GetField<int32_t>(VT_CATEGORY, 0);
  }
  bool mutate_category(int32_t _category) {
    return SetField<int32_t>(VT_CATEGORY, _category, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyField<int32_t>(verifier, VT_CATEGORY) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
  }
  void add_category(int32_t category) {
    fbb_.AddElement<int32_t>(Error::VT_CATEGORY, category, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    int32_t category = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_category(category);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    int32_t category = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return futureheadapi::CreateError(
      _fbb,
      code,
      category,
      message__);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SuccessT : public flatbuffers::NativeTable {
  typedef Success TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.SuccessT";
  }
  std::string message;
  SuccessT() {
  }
};

struct Success FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SuccessT NativeTableType;
  typedef SuccessBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SuccessTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.Success";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  SuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Success> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SuccessBuilder {
  typedef Success Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Success::VT_MESSAGE, message);
  }
  explicit SuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SuccessBuilder &operator=(const SuccessBuilder &);
  flatbuffers::Offset<Success> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Success>(end);
    return o;
  }
};

inline flatbuffers::Offset<Success> CreateSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  SuccessBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Success> CreateSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return futureheadapi::CreateSuccess(
      _fbb,
      message__);
}

flatbuffers::Offset<Success> CreateSuccess(flatbuffers::FlatBufferBuilder &_fbb, const SuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IsAliveT : public flatbuffers::NativeTable {
  typedef IsAlive TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.IsAliveT";
  }
  IsAliveT() {
  }
};

struct IsAlive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IsAliveT NativeTableType;
  typedef IsAliveBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IsAliveTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.IsAlive";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  IsAliveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IsAliveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IsAlive> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsAliveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IsAliveBuilder {
  typedef IsAlive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IsAliveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IsAliveBuilder &operator=(const IsAliveBuilder &);
  flatbuffers::Offset<IsAlive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IsAlive>(end);
    return o;
  }
};

inline flatbuffers::Offset<IsAlive> CreateIsAlive(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IsAliveBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<IsAlive> CreateIsAlive(flatbuffers::FlatBufferBuilder &_fbb, const IsAliveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnvelopeT : public flatbuffers::NativeTable {
  typedef Envelope TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.EnvelopeT";
  }
  uint64_t time;
  std::string credentials;
  std::string correlation_id;
  futureheadapi::MessageUnion message;
  EnvelopeT()
      : time(0) {
  }
};

struct Envelope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnvelopeT NativeTableType;
  typedef EnvelopeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EnvelopeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "futureheadapi.Envelope";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CREDENTIALS = 6,
    VT_CORRELATION_ID = 8,
    VT_MESSAGE_TYPE = 10,
    VT_MESSAGE = 12
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool mutate_time(uint64_t _time) {
    return SetField<uint64_t>(VT_TIME, _time, 0);
  }
  const flatbuffers::String *credentials() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIALS);
  }
  flatbuffers::String *mutable_credentials() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIALS);
  }
  const flatbuffers::String *correlation_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CORRELATION_ID);
  }
  flatbuffers::String *mutable_correlation_id() {
    return GetPointer<flatbuffers::String *>(VT_CORRELATION_ID);
  }
  futureheadapi::Message message_type() const {
    return static_cast<futureheadapi::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const futureheadapi::Error *message_as_Error() const {
    return message_type() == futureheadapi::Message_Error ? static_cast<const futureheadapi::Error *>(message()) : nullptr;
  }
  const futureheadapi::Success *message_as_Success() const {
    return message_type() == futureheadapi::Message_Success ? static_cast<const futureheadapi::Success *>(message()) : nullptr;
  }
  const futureheadapi::IsAlive *message_as_IsAlive() const {
    return message_type() == futureheadapi::Message_IsAlive ? static_cast<const futureheadapi::IsAlive *>(message()) : nullptr;
  }
  const futureheadapi::EventAck *message_as_EventAck() const {
    return message_type() == futureheadapi::Message_EventAck ? static_cast<const futureheadapi::EventAck *>(message()) : nullptr;
  }
  const futureheadapi::BlockInfo *message_as_BlockInfo() const {
    return message_type() == futureheadapi::Message_BlockInfo ? static_cast<const futureheadapi::BlockInfo *>(message()) : nullptr;
  }
  const futureheadapi::AccountWeight *message_as_AccountWeight() const {
    return message_type() == futureheadapi::Message_AccountWeight ? static_cast<const futureheadapi::AccountWeight *>(message()) : nullptr;
  }
  const futureheadapi::AccountWeightResponse *message_as_AccountWeightResponse() const {
    return message_type() == futureheadapi::Message_AccountWeightResponse ? static_cast<const futureheadapi::AccountWeightResponse *>(message()) : nullptr;
  }
  const futureheadapi::TopicConfirmation *message_as_TopicConfirmation() const {
    return message_type() == futureheadapi::Message_TopicConfirmation ? static_cast<const futureheadapi::TopicConfirmation *>(message()) : nullptr;
  }
  const futureheadapi::EventConfirmation *message_as_EventConfirmation() const {
    return message_type() == futureheadapi::Message_EventConfirmation ? static_cast<const futureheadapi::EventConfirmation *>(message()) : nullptr;
  }
  const futureheadapi::ServiceRegister *message_as_ServiceRegister() const {
    return message_type() == futureheadapi::Message_ServiceRegister ? static_cast<const futureheadapi::ServiceRegister *>(message()) : nullptr;
  }
  const futureheadapi::ServiceStop *message_as_ServiceStop() const {
    return message_type() == futureheadapi::Message_ServiceStop ? static_cast<const futureheadapi::ServiceStop *>(message()) : nullptr;
  }
  const futureheadapi::TopicServiceStop *message_as_TopicServiceStop() const {
    return message_type() == futureheadapi::Message_TopicServiceStop ? static_cast<const futureheadapi::TopicServiceStop *>(message()) : nullptr;
  }
  const futureheadapi::EventServiceStop *message_as_EventServiceStop() const {
    return message_type() == futureheadapi::Message_EventServiceStop ? static_cast<const futureheadapi::EventServiceStop *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CREDENTIALS) &&
           verifier.VerifyString(credentials()) &&
           VerifyOffset(verifier, VT_CORRELATION_ID) &&
           verifier.VerifyString(correlation_id()) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  EnvelopeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnvelopeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Envelope> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const futureheadapi::Error *Envelope::message_as<futureheadapi::Error>() const {
  return message_as_Error();
}

template<> inline const futureheadapi::Success *Envelope::message_as<futureheadapi::Success>() const {
  return message_as_Success();
}

template<> inline const futureheadapi::IsAlive *Envelope::message_as<futureheadapi::IsAlive>() const {
  return message_as_IsAlive();
}

template<> inline const futureheadapi::EventAck *Envelope::message_as<futureheadapi::EventAck>() const {
  return message_as_EventAck();
}

template<> inline const futureheadapi::BlockInfo *Envelope::message_as<futureheadapi::BlockInfo>() const {
  return message_as_BlockInfo();
}

template<> inline const futureheadapi::AccountWeight *Envelope::message_as<futureheadapi::AccountWeight>() const {
  return message_as_AccountWeight();
}

template<> inline const futureheadapi::AccountWeightResponse *Envelope::message_as<futureheadapi::AccountWeightResponse>() const {
  return message_as_AccountWeightResponse();
}

template<> inline const futureheadapi::TopicConfirmation *Envelope::message_as<futureheadapi::TopicConfirmation>() const {
  return message_as_TopicConfirmation();
}

template<> inline const futureheadapi::EventConfirmation *Envelope::message_as<futureheadapi::EventConfirmation>() const {
  return message_as_EventConfirmation();
}

template<> inline const futureheadapi::ServiceRegister *Envelope::message_as<futureheadapi::ServiceRegister>() const {
  return message_as_ServiceRegister();
}

template<> inline const futureheadapi::ServiceStop *Envelope::message_as<futureheadapi::ServiceStop>() const {
  return message_as_ServiceStop();
}

template<> inline const futureheadapi::TopicServiceStop *Envelope::message_as<futureheadapi::TopicServiceStop>() const {
  return message_as_TopicServiceStop();
}

template<> inline const futureheadapi::EventServiceStop *Envelope::message_as<futureheadapi::EventServiceStop>() const {
  return message_as_EventServiceStop();
}

struct EnvelopeBuilder {
  typedef Envelope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(Envelope::VT_TIME, time, 0);
  }
  void add_credentials(flatbuffers::Offset<flatbuffers::String> credentials) {
    fbb_.AddOffset(Envelope::VT_CREDENTIALS, credentials);
  }
  void add_correlation_id(flatbuffers::Offset<flatbuffers::String> correlation_id) {
    fbb_.AddOffset(Envelope::VT_CORRELATION_ID, correlation_id);
  }
  void add_message_type(futureheadapi::Message message_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Envelope::VT_MESSAGE, message);
  }
  explicit EnvelopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnvelopeBuilder &operator=(const EnvelopeBuilder &);
  flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline flatbuffers::Offset<Envelope> CreateEnvelope(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> credentials = 0,
    flatbuffers::Offset<flatbuffers::String> correlation_id = 0,
    futureheadapi::Message message_type = futureheadapi::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_message(message);
  builder_.add_correlation_id(correlation_id);
  builder_.add_credentials(credentials);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Envelope> CreateEnvelopeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    const char *credentials = nullptr,
    const char *correlation_id = nullptr,
    futureheadapi::Message message_type = futureheadapi::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  auto credentials__ = credentials ? _fbb.CreateString(credentials) : 0;
  auto correlation_id__ = correlation_id ? _fbb.CreateString(correlation_id) : 0;
  return futureheadapi::CreateEnvelope(
      _fbb,
      time,
      credentials__,
      correlation_id__,
      message_type,
      message);
}

flatbuffers::Offset<Envelope> CreateEnvelope(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AccountWeightT *AccountWeight::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AccountWeightT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AccountWeight::UnPackTo(AccountWeightT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = account(); if (_e) _o->account = _e->str(); }
}

inline flatbuffers::Offset<AccountWeight> AccountWeight::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccountWeight(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AccountWeight> CreateAccountWeight(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AccountWeightT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _account = _fbb.CreateString(_o->account);
  return futureheadapi::CreateAccountWeight(
      _fbb,
      _account);
}

inline AccountWeightResponseT *AccountWeightResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AccountWeightResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AccountWeightResponse::UnPackTo(AccountWeightResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = voting_weight(); if (_e) _o->voting_weight = _e->str(); }
}

inline flatbuffers::Offset<AccountWeightResponse> AccountWeightResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccountWeightResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AccountWeightResponse> CreateAccountWeightResponse(flatbuffers::FlatBufferBuilder &_fbb, const AccountWeightResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AccountWeightResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _voting_weight = _fbb.CreateString(_o->voting_weight);
  return futureheadapi::CreateAccountWeightResponse(
      _fbb,
      _voting_weight);
}

inline BlockOpenT *BlockOpen::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockOpenT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockOpen::UnPackTo(BlockOpenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = account(); if (_e) _o->account = _e->str(); }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
  { auto _e = representative(); if (_e) _o->representative = _e->str(); }
  { auto _e = signature(); if (_e) _o->signature = _e->str(); }
  { auto _e = work(); if (_e) _o->work = _e->str(); }
}

inline flatbuffers::Offset<BlockOpen> BlockOpen::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockOpen(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockOpen> CreateBlockOpen(flatbuffers::FlatBufferBuilder &_fbb, const BlockOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockOpenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _account = _o->account.empty() ? 0 : _fbb.CreateString(_o->account);
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  auto _representative = _o->representative.empty() ? 0 : _fbb.CreateString(_o->representative);
  auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
  auto _work = _o->work.empty() ? 0 : _fbb.CreateString(_o->work);
  return futureheadapi::CreateBlockOpen(
      _fbb,
      _hash,
      _account,
      _source,
      _representative,
      _signature,
      _work);
}

inline BlockReceiveT *BlockReceive::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockReceiveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockReceive::UnPackTo(BlockReceiveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = previous(); if (_e) _o->previous = _e->str(); }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
  { auto _e = signature(); if (_e) _o->signature = _e->str(); }
  { auto _e = work(); if (_e) _o->work = _e->str(); }
}

inline flatbuffers::Offset<BlockReceive> BlockReceive::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockReceiveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockReceive(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockReceive> CreateBlockReceive(flatbuffers::FlatBufferBuilder &_fbb, const BlockReceiveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockReceiveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _previous = _o->previous.empty() ? 0 : _fbb.CreateString(_o->previous);
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
  auto _work = _o->work.empty() ? 0 : _fbb.CreateString(_o->work);
  return futureheadapi::CreateBlockReceive(
      _fbb,
      _hash,
      _previous,
      _source,
      _signature,
      _work);
}

inline BlockSendT *BlockSend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockSendT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockSend::UnPackTo(BlockSendT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = previous(); if (_e) _o->previous = _e->str(); }
  { auto _e = destination(); if (_e) _o->destination = _e->str(); }
  { auto _e = balance(); if (_e) _o->balance = _e->str(); }
  { auto _e = signature(); if (_e) _o->signature = _e->str(); }
  { auto _e = work(); if (_e) _o->work = _e->str(); }
}

inline flatbuffers::Offset<BlockSend> BlockSend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockSendT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockSend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockSend> CreateBlockSend(flatbuffers::FlatBufferBuilder &_fbb, const BlockSendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockSendT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _previous = _o->previous.empty() ? 0 : _fbb.CreateString(_o->previous);
  auto _destination = _o->destination.empty() ? 0 : _fbb.CreateString(_o->destination);
  auto _balance = _o->balance.empty() ? 0 : _fbb.CreateString(_o->balance);
  auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
  auto _work = _o->work.empty() ? 0 : _fbb.CreateString(_o->work);
  return futureheadapi::CreateBlockSend(
      _fbb,
      _hash,
      _previous,
      _destination,
      _balance,
      _signature,
      _work);
}

inline BlockChangeT *BlockChange::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockChangeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockChange::UnPackTo(BlockChangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = previous(); if (_e) _o->previous = _e->str(); }
  { auto _e = representative(); if (_e) _o->representative = _e->str(); }
  { auto _e = signature(); if (_e) _o->signature = _e->str(); }
  { auto _e = work(); if (_e) _o->work = _e->str(); }
}

inline flatbuffers::Offset<BlockChange> BlockChange::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockChangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockChange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockChange> CreateBlockChange(flatbuffers::FlatBufferBuilder &_fbb, const BlockChangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockChangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _previous = _o->previous.empty() ? 0 : _fbb.CreateString(_o->previous);
  auto _representative = _o->representative.empty() ? 0 : _fbb.CreateString(_o->representative);
  auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
  auto _work = _o->work.empty() ? 0 : _fbb.CreateString(_o->work);
  return futureheadapi::CreateBlockChange(
      _fbb,
      _hash,
      _previous,
      _representative,
      _signature,
      _work);
}

inline BlockStateT *BlockState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockState::UnPackTo(BlockStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = account(); if (_e) _o->account = _e->str(); }
  { auto _e = previous(); if (_e) _o->previous = _e->str(); }
  { auto _e = representative(); if (_e) _o->representative = _e->str(); }
  { auto _e = balance(); if (_e) _o->balance = _e->str(); }
  { auto _e = link(); if (_e) _o->link = _e->str(); }
  { auto _e = link_as_account(); if (_e) _o->link_as_account = _e->str(); }
  { auto _e = signature(); if (_e) _o->signature = _e->str(); }
  { auto _e = work(); if (_e) _o->work = _e->str(); }
  { auto _e = subtype(); _o->subtype = _e; }
}

inline flatbuffers::Offset<BlockState> BlockState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockState> CreateBlockState(flatbuffers::FlatBufferBuilder &_fbb, const BlockStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _account = _o->account.empty() ? 0 : _fbb.CreateString(_o->account);
  auto _previous = _o->previous.empty() ? 0 : _fbb.CreateString(_o->previous);
  auto _representative = _o->representative.empty() ? 0 : _fbb.CreateString(_o->representative);
  auto _balance = _o->balance.empty() ? 0 : _fbb.CreateString(_o->balance);
  auto _link = _o->link.empty() ? 0 : _fbb.CreateString(_o->link);
  auto _link_as_account = _o->link_as_account.empty() ? 0 : _fbb.CreateString(_o->link_as_account);
  auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
  auto _work = _o->work.empty() ? 0 : _fbb.CreateString(_o->work);
  auto _subtype = _o->subtype;
  return futureheadapi::CreateBlockState(
      _fbb,
      _hash,
      _account,
      _previous,
      _representative,
      _balance,
      _link,
      _link_as_account,
      _signature,
      _work,
      _subtype);
}

inline BlockInfoT *BlockInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockInfo::UnPackTo(BlockInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_type(); _o->block.type = _e; }
  { auto _e = block(); if (_e) _o->block.value = futureheadapi::BlockUnion::UnPack(_e, block_type(), _resolver); }
}

inline flatbuffers::Offset<BlockInfo> BlockInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockInfo> CreateBlockInfo(flatbuffers::FlatBufferBuilder &_fbb, const BlockInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_type = _o->block.type;
  auto _block = _o->block.Pack(_fbb);
  return futureheadapi::CreateBlockInfo(
      _fbb,
      _block_type,
      _block);
}

inline ServiceRegisterT *ServiceRegister::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServiceRegisterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ServiceRegister::UnPackTo(ServiceRegisterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = service_name(); if (_e) _o->service_name = _e->str(); }
}

inline flatbuffers::Offset<ServiceRegister> ServiceRegister::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceRegisterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServiceRegister(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServiceRegister> CreateServiceRegister(flatbuffers::FlatBufferBuilder &_fbb, const ServiceRegisterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServiceRegisterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _service_name = _o->service_name.empty() ? 0 : _fbb.CreateString(_o->service_name);
  return futureheadapi::CreateServiceRegister(
      _fbb,
      _service_name);
}

inline ServiceStopT *ServiceStop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServiceStopT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ServiceStop::UnPackTo(ServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = service_name(); if (_e) _o->service_name = _e->str(); }
  { auto _e = restart(); _o->restart = _e; }
}

inline flatbuffers::Offset<ServiceStop> ServiceStop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServiceStop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServiceStop> CreateServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const ServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServiceStopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _service_name = _fbb.CreateString(_o->service_name);
  auto _restart = _o->restart;
  return futureheadapi::CreateServiceStop(
      _fbb,
      _service_name,
      _restart);
}

inline TopicServiceStopT *TopicServiceStop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopicServiceStopT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopicServiceStop::UnPackTo(TopicServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = unsubscribe(); _o->unsubscribe = _e; }
}

inline flatbuffers::Offset<TopicServiceStop> TopicServiceStop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopicServiceStop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicServiceStop> CreateTopicServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const TopicServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopicServiceStopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _unsubscribe = _o->unsubscribe;
  return futureheadapi::CreateTopicServiceStop(
      _fbb,
      _unsubscribe);
}

inline EventServiceStopT *EventServiceStop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EventServiceStopT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EventServiceStop::UnPackTo(EventServiceStopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EventServiceStop> EventServiceStop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventServiceStopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventServiceStop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventServiceStop> CreateEventServiceStop(flatbuffers::FlatBufferBuilder &_fbb, const EventServiceStopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EventServiceStopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return futureheadapi::CreateEventServiceStop(
      _fbb);
}

inline EventAckT *EventAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EventAckT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EventAck::UnPackTo(EventAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EventAck> EventAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventAckT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventAck> CreateEventAck(flatbuffers::FlatBufferBuilder &_fbb, const EventAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EventAckT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return futureheadapi::CreateEventAck(
      _fbb);
}

inline TopicConfirmationT *TopicConfirmation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopicConfirmationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopicConfirmation::UnPackTo(TopicConfirmationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = unsubscribe(); _o->unsubscribe = _e; }
  { auto _e = options(); if (_e) _o->options = std::unique_ptr<futureheadapi::TopicConfirmationOptionsT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<TopicConfirmation> TopicConfirmation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopicConfirmation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicConfirmation> CreateTopicConfirmation(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopicConfirmationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _unsubscribe = _o->unsubscribe;
  auto _options = _o->options ? CreateTopicConfirmationOptions(_fbb, _o->options.get(), _rehasher) : 0;
  return futureheadapi::CreateTopicConfirmation(
      _fbb,
      _unsubscribe,
      _options);
}

inline TopicConfirmationOptionsT *TopicConfirmationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopicConfirmationOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopicConfirmationOptions::UnPackTo(TopicConfirmationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = confirmation_type_filter(); _o->confirmation_type_filter = _e; }
  { auto _e = all_local_accounts(); _o->all_local_accounts = _e; }
  { auto _e = accounts(); if (_e) { _o->accounts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->accounts[_i] = _e->Get(_i)->str(); } } }
  { auto _e = include_block(); _o->include_block = _e; }
  { auto _e = include_election_info(); _o->include_election_info = _e; }
}

inline flatbuffers::Offset<TopicConfirmationOptions> TopicConfirmationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopicConfirmationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicConfirmationOptions> CreateTopicConfirmationOptions(flatbuffers::FlatBufferBuilder &_fbb, const TopicConfirmationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopicConfirmationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _confirmation_type_filter = _o->confirmation_type_filter;
  auto _all_local_accounts = _o->all_local_accounts;
  auto _accounts = _fbb.CreateVectorOfStrings(_o->accounts);
  auto _include_block = _o->include_block;
  auto _include_election_info = _o->include_election_info;
  return futureheadapi::CreateTopicConfirmationOptions(
      _fbb,
      _confirmation_type_filter,
      _all_local_accounts,
      _accounts,
      _include_block,
      _include_election_info);
}

inline EventConfirmationT *EventConfirmation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EventConfirmationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EventConfirmation::UnPackTo(EventConfirmationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = confirmation_type(); _o->confirmation_type = _e; }
  { auto _e = account(); if (_e) _o->account = _e->str(); }
  { auto _e = amount(); if (_e) _o->amount = _e->str(); }
  { auto _e = hash(); if (_e) _o->hash = _e->str(); }
  { auto _e = block_type(); _o->block.type = _e; }
  { auto _e = block(); if (_e) _o->block.value = futureheadapi::BlockUnion::UnPack(_e, block_type(), _resolver); }
  { auto _e = election_info(); if (_e) _o->election_info = std::unique_ptr<futureheadapi::ElectionInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EventConfirmation> EventConfirmation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventConfirmationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventConfirmation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventConfirmation> CreateEventConfirmation(flatbuffers::FlatBufferBuilder &_fbb, const EventConfirmationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EventConfirmationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _confirmation_type = _o->confirmation_type;
  auto _account = _o->account.empty() ? 0 : _fbb.CreateString(_o->account);
  auto _amount = _o->amount.empty() ? 0 : _fbb.CreateString(_o->amount);
  auto _hash = _o->hash.empty() ? 0 : _fbb.CreateString(_o->hash);
  auto _block_type = _o->block.type;
  auto _block = _o->block.Pack(_fbb);
  auto _election_info = _o->election_info ? CreateElectionInfo(_fbb, _o->election_info.get(), _rehasher) : 0;
  return futureheadapi::CreateEventConfirmation(
      _fbb,
      _confirmation_type,
      _account,
      _amount,
      _hash,
      _block_type,
      _block,
      _election_info);
}

inline ElectionInfoT *ElectionInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ElectionInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ElectionInfo::UnPackTo(ElectionInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = duration(); _o->duration = _e; }
  { auto _e = time(); _o->time = _e; }
  { auto _e = tally(); if (_e) _o->tally = _e->str(); }
  { auto _e = request_count(); _o->request_count = _e; }
  { auto _e = block_count(); _o->block_count = _e; }
  { auto _e = voter_count(); _o->voter_count = _e; }
}

inline flatbuffers::Offset<ElectionInfo> ElectionInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElectionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElectionInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ElectionInfo> CreateElectionInfo(flatbuffers::FlatBufferBuilder &_fbb, const ElectionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ElectionInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _duration = _o->duration;
  auto _time = _o->time;
  auto _tally = _o->tally.empty() ? 0 : _fbb.CreateString(_o->tally);
  auto _request_count = _o->request_count;
  auto _block_count = _o->block_count;
  auto _voter_count = _o->voter_count;
  return futureheadapi::CreateElectionInfo(
      _fbb,
      _duration,
      _time,
      _tally,
      _request_count,
      _block_count,
      _voter_count);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ErrorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; }
  { auto _e = category(); _o->category = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _category = _o->category;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return futureheadapi::CreateError(
      _fbb,
      _code,
      _category,
      _message);
}

inline SuccessT *Success::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Success::UnPackTo(SuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Success> Success::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Success> CreateSuccess(flatbuffers::FlatBufferBuilder &_fbb, const SuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SuccessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return futureheadapi::CreateSuccess(
      _fbb,
      _message);
}

inline IsAliveT *IsAlive::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IsAliveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IsAlive::UnPackTo(IsAliveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<IsAlive> IsAlive::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsAliveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIsAlive(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IsAlive> CreateIsAlive(flatbuffers::FlatBufferBuilder &_fbb, const IsAliveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IsAliveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return futureheadapi::CreateIsAlive(
      _fbb);
}

inline EnvelopeT *Envelope::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EnvelopeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Envelope::UnPackTo(EnvelopeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time(); _o->time = _e; }
  { auto _e = credentials(); if (_e) _o->credentials = _e->str(); }
  { auto _e = correlation_id(); if (_e) _o->correlation_id = _e->str(); }
  { auto _e = message_type(); _o->message.type = _e; }
  { auto _e = message(); if (_e) _o->message.value = futureheadapi::MessageUnion::UnPack(_e, message_type(), _resolver); }
}

inline flatbuffers::Offset<Envelope> Envelope::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnvelope(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Envelope> CreateEnvelope(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnvelopeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time = _o->time;
  auto _credentials = _o->credentials.empty() ? 0 : _fbb.CreateString(_o->credentials);
  auto _correlation_id = _o->correlation_id.empty() ? 0 : _fbb.CreateString(_o->correlation_id);
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return futureheadapi::CreateEnvelope(
      _fbb,
      _time,
      _credentials,
      _correlation_id,
      _message_type,
      _message);
}

inline bool VerifyBlock(flatbuffers::Verifier &verifier, const void *obj, Block type) {
  switch (type) {
    case Block_NONE: {
      return true;
    }
    case Block_BlockState: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Block_BlockOpen: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockOpen *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Block_BlockReceive: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockReceive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Block_BlockSend: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockSend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Block_BlockChange: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBlockVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBlock(
        verifier,  values->Get(i), types->GetEnum<Block>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BlockUnion::UnPack(const void *obj, Block type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Block_BlockState: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockState *>(obj);
      return ptr->UnPack(resolver);
    }
    case Block_BlockOpen: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockOpen *>(obj);
      return ptr->UnPack(resolver);
    }
    case Block_BlockReceive: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockReceive *>(obj);
      return ptr->UnPack(resolver);
    }
    case Block_BlockSend: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockSend *>(obj);
      return ptr->UnPack(resolver);
    }
    case Block_BlockChange: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockChange *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BlockUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Block_BlockState: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockStateT *>(value);
      return CreateBlockState(_fbb, ptr, _rehasher).Union();
    }
    case Block_BlockOpen: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockOpenT *>(value);
      return CreateBlockOpen(_fbb, ptr, _rehasher).Union();
    }
    case Block_BlockReceive: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockReceiveT *>(value);
      return CreateBlockReceive(_fbb, ptr, _rehasher).Union();
    }
    case Block_BlockSend: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockSendT *>(value);
      return CreateBlockSend(_fbb, ptr, _rehasher).Union();
    }
    case Block_BlockChange: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockChangeT *>(value);
      return CreateBlockChange(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BlockUnion::BlockUnion(const BlockUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Block_BlockState: {
      value = new futureheadapi::BlockStateT(*reinterpret_cast<futureheadapi::BlockStateT *>(u.value));
      break;
    }
    case Block_BlockOpen: {
      value = new futureheadapi::BlockOpenT(*reinterpret_cast<futureheadapi::BlockOpenT *>(u.value));
      break;
    }
    case Block_BlockReceive: {
      value = new futureheadapi::BlockReceiveT(*reinterpret_cast<futureheadapi::BlockReceiveT *>(u.value));
      break;
    }
    case Block_BlockSend: {
      value = new futureheadapi::BlockSendT(*reinterpret_cast<futureheadapi::BlockSendT *>(u.value));
      break;
    }
    case Block_BlockChange: {
      value = new futureheadapi::BlockChangeT(*reinterpret_cast<futureheadapi::BlockChangeT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BlockUnion::Reset() {
  switch (type) {
    case Block_BlockState: {
      auto ptr = reinterpret_cast<futureheadapi::BlockStateT *>(value);
      delete ptr;
      break;
    }
    case Block_BlockOpen: {
      auto ptr = reinterpret_cast<futureheadapi::BlockOpenT *>(value);
      delete ptr;
      break;
    }
    case Block_BlockReceive: {
      auto ptr = reinterpret_cast<futureheadapi::BlockReceiveT *>(value);
      delete ptr;
      break;
    }
    case Block_BlockSend: {
      auto ptr = reinterpret_cast<futureheadapi::BlockSendT *>(value);
      delete ptr;
      break;
    }
    case Block_BlockChange: {
      auto ptr = reinterpret_cast<futureheadapi::BlockChangeT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Block_NONE;
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Error: {
      auto ptr = reinterpret_cast<const futureheadapi::Error *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Success: {
      auto ptr = reinterpret_cast<const futureheadapi::Success *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_IsAlive: {
      auto ptr = reinterpret_cast<const futureheadapi::IsAlive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_EventAck: {
      auto ptr = reinterpret_cast<const futureheadapi::EventAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_BlockInfo: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AccountWeight: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeight *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AccountWeightResponse: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeightResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TopicConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicConfirmation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_EventConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::EventConfirmation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ServiceRegister: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceRegister *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TopicServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicServiceStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_EventServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::EventServiceStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageUnion::UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Message_Error: {
      auto ptr = reinterpret_cast<const futureheadapi::Error *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_Success: {
      auto ptr = reinterpret_cast<const futureheadapi::Success *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_IsAlive: {
      auto ptr = reinterpret_cast<const futureheadapi::IsAlive *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_EventAck: {
      auto ptr = reinterpret_cast<const futureheadapi::EventAck *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_BlockInfo: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_AccountWeight: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeight *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_AccountWeightResponse: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeightResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_TopicConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicConfirmation *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_EventConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::EventConfirmation *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_ServiceRegister: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceRegister *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_ServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceStop *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_TopicServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicServiceStop *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_EventServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::EventServiceStop *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Message_Error: {
      auto ptr = reinterpret_cast<const futureheadapi::ErrorT *>(value);
      return CreateError(_fbb, ptr, _rehasher).Union();
    }
    case Message_Success: {
      auto ptr = reinterpret_cast<const futureheadapi::SuccessT *>(value);
      return CreateSuccess(_fbb, ptr, _rehasher).Union();
    }
    case Message_IsAlive: {
      auto ptr = reinterpret_cast<const futureheadapi::IsAliveT *>(value);
      return CreateIsAlive(_fbb, ptr, _rehasher).Union();
    }
    case Message_EventAck: {
      auto ptr = reinterpret_cast<const futureheadapi::EventAckT *>(value);
      return CreateEventAck(_fbb, ptr, _rehasher).Union();
    }
    case Message_BlockInfo: {
      auto ptr = reinterpret_cast<const futureheadapi::BlockInfoT *>(value);
      return CreateBlockInfo(_fbb, ptr, _rehasher).Union();
    }
    case Message_AccountWeight: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeightT *>(value);
      return CreateAccountWeight(_fbb, ptr, _rehasher).Union();
    }
    case Message_AccountWeightResponse: {
      auto ptr = reinterpret_cast<const futureheadapi::AccountWeightResponseT *>(value);
      return CreateAccountWeightResponse(_fbb, ptr, _rehasher).Union();
    }
    case Message_TopicConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicConfirmationT *>(value);
      return CreateTopicConfirmation(_fbb, ptr, _rehasher).Union();
    }
    case Message_EventConfirmation: {
      auto ptr = reinterpret_cast<const futureheadapi::EventConfirmationT *>(value);
      return CreateEventConfirmation(_fbb, ptr, _rehasher).Union();
    }
    case Message_ServiceRegister: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceRegisterT *>(value);
      return CreateServiceRegister(_fbb, ptr, _rehasher).Union();
    }
    case Message_ServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::ServiceStopT *>(value);
      return CreateServiceStop(_fbb, ptr, _rehasher).Union();
    }
    case Message_TopicServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::TopicServiceStopT *>(value);
      return CreateTopicServiceStop(_fbb, ptr, _rehasher).Union();
    }
    case Message_EventServiceStop: {
      auto ptr = reinterpret_cast<const futureheadapi::EventServiceStopT *>(value);
      return CreateEventServiceStop(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageUnion::MessageUnion(const MessageUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Message_Error: {
      value = new futureheadapi::ErrorT(*reinterpret_cast<futureheadapi::ErrorT *>(u.value));
      break;
    }
    case Message_Success: {
      value = new futureheadapi::SuccessT(*reinterpret_cast<futureheadapi::SuccessT *>(u.value));
      break;
    }
    case Message_IsAlive: {
      value = new futureheadapi::IsAliveT(*reinterpret_cast<futureheadapi::IsAliveT *>(u.value));
      break;
    }
    case Message_EventAck: {
      value = new futureheadapi::EventAckT(*reinterpret_cast<futureheadapi::EventAckT *>(u.value));
      break;
    }
    case Message_BlockInfo: {
      value = new futureheadapi::BlockInfoT(*reinterpret_cast<futureheadapi::BlockInfoT *>(u.value));
      break;
    }
    case Message_AccountWeight: {
      value = new futureheadapi::AccountWeightT(*reinterpret_cast<futureheadapi::AccountWeightT *>(u.value));
      break;
    }
    case Message_AccountWeightResponse: {
      value = new futureheadapi::AccountWeightResponseT(*reinterpret_cast<futureheadapi::AccountWeightResponseT *>(u.value));
      break;
    }
    case Message_TopicConfirmation: {
      FLATBUFFERS_ASSERT(false);  // futureheadapi::TopicConfirmationT not copyable.
      break;
    }
    case Message_EventConfirmation: {
      FLATBUFFERS_ASSERT(false);  // futureheadapi::EventConfirmationT not copyable.
      break;
    }
    case Message_ServiceRegister: {
      value = new futureheadapi::ServiceRegisterT(*reinterpret_cast<futureheadapi::ServiceRegisterT *>(u.value));
      break;
    }
    case Message_ServiceStop: {
      value = new futureheadapi::ServiceStopT(*reinterpret_cast<futureheadapi::ServiceStopT *>(u.value));
      break;
    }
    case Message_TopicServiceStop: {
      value = new futureheadapi::TopicServiceStopT(*reinterpret_cast<futureheadapi::TopicServiceStopT *>(u.value));
      break;
    }
    case Message_EventServiceStop: {
      value = new futureheadapi::EventServiceStopT(*reinterpret_cast<futureheadapi::EventServiceStopT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageUnion::Reset() {
  switch (type) {
    case Message_Error: {
      auto ptr = reinterpret_cast<futureheadapi::ErrorT *>(value);
      delete ptr;
      break;
    }
    case Message_Success: {
      auto ptr = reinterpret_cast<futureheadapi::SuccessT *>(value);
      delete ptr;
      break;
    }
    case Message_IsAlive: {
      auto ptr = reinterpret_cast<futureheadapi::IsAliveT *>(value);
      delete ptr;
      break;
    }
    case Message_EventAck: {
      auto ptr = reinterpret_cast<futureheadapi::EventAckT *>(value);
      delete ptr;
      break;
    }
    case Message_BlockInfo: {
      auto ptr = reinterpret_cast<futureheadapi::BlockInfoT *>(value);
      delete ptr;
      break;
    }
    case Message_AccountWeight: {
      auto ptr = reinterpret_cast<futureheadapi::AccountWeightT *>(value);
      delete ptr;
      break;
    }
    case Message_AccountWeightResponse: {
      auto ptr = reinterpret_cast<futureheadapi::AccountWeightResponseT *>(value);
      delete ptr;
      break;
    }
    case Message_TopicConfirmation: {
      auto ptr = reinterpret_cast<futureheadapi::TopicConfirmationT *>(value);
      delete ptr;
      break;
    }
    case Message_EventConfirmation: {
      auto ptr = reinterpret_cast<futureheadapi::EventConfirmationT *>(value);
      delete ptr;
      break;
    }
    case Message_ServiceRegister: {
      auto ptr = reinterpret_cast<futureheadapi::ServiceRegisterT *>(value);
      delete ptr;
      break;
    }
    case Message_ServiceStop: {
      auto ptr = reinterpret_cast<futureheadapi::ServiceStopT *>(value);
      delete ptr;
      break;
    }
    case Message_TopicServiceStop: {
      auto ptr = reinterpret_cast<futureheadapi::TopicServiceStopT *>(value);
      delete ptr;
      break;
    }
    case Message_EventServiceStop: {
      auto ptr = reinterpret_cast<futureheadapi::EventServiceStopT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Message_NONE;
}

inline const flatbuffers::TypeTable *BlockSubTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::BlockSubTypeTypeTable
  };
  static const char * const names[] = {
    "invalid",
    "receive",
    "send",
    "change",
    "epoch"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::BlockStateTypeTable,
    futureheadapi::BlockOpenTypeTable,
    futureheadapi::BlockReceiveTypeTable,
    futureheadapi::BlockSendTypeTable,
    futureheadapi::BlockChangeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "BlockState",
    "BlockOpen",
    "BlockReceive",
    "BlockSend",
    "BlockChange"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopicConfirmationTypeFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::TopicConfirmationTypeFilterTypeTable
  };
  static const char * const names[] = {
    "all",
    "active",
    "active_quorum",
    "active_confirmation_height",
    "inactive"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopicConfirmationTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::TopicConfirmationTypeTypeTable
  };
  static const char * const names[] = {
    "active_quorum",
    "active_confirmation_height",
    "inactive"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::ErrorTypeTable,
    futureheadapi::SuccessTypeTable,
    futureheadapi::IsAliveTypeTable,
    futureheadapi::EventAckTypeTable,
    futureheadapi::BlockInfoTypeTable,
    futureheadapi::AccountWeightTypeTable,
    futureheadapi::AccountWeightResponseTypeTable,
    futureheadapi::TopicConfirmationTypeTable,
    futureheadapi::EventConfirmationTypeTable,
    futureheadapi::ServiceRegisterTypeTable,
    futureheadapi::ServiceStopTypeTable,
    futureheadapi::TopicServiceStopTypeTable,
    futureheadapi::EventServiceStopTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Error",
    "Success",
    "IsAlive",
    "EventAck",
    "BlockInfo",
    "AccountWeight",
    "AccountWeightResponse",
    "TopicConfirmation",
    "EventConfirmation",
    "ServiceRegister",
    "ServiceStop",
    "TopicServiceStop",
    "EventServiceStop"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AccountWeightTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "account"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AccountWeightResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "voting_weight"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockOpenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "hash",
    "account",
    "source",
    "representative",
    "signature",
    "work"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockReceiveTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "hash",
    "previous",
    "source",
    "signature",
    "work"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockSendTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "hash",
    "previous",
    "destination",
    "balance",
    "signature",
    "work"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockChangeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "hash",
    "previous",
    "representative",
    "signature",
    "work"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockStateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::BlockSubTypeTypeTable
  };
  static const char * const names[] = {
    "hash",
    "account",
    "previous",
    "representative",
    "balance",
    "link",
    "link_as_account",
    "signature",
    "work",
    "subtype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::BlockTypeTable
  };
  static const char * const names[] = {
    "block_type",
    "block"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServiceRegisterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "service_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServiceStopTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "service_name",
    "restart"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopicServiceStopTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "unsubscribe"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventServiceStopTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventAckTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopicConfirmationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::TopicConfirmationOptionsTypeTable
  };
  static const char * const names[] = {
    "unsubscribe",
    "options"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopicConfirmationOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::TopicConfirmationTypeFilterTypeTable
  };
  static const char * const names[] = {
    "confirmation_type_filter",
    "all_local_accounts",
    "accounts",
    "include_block",
    "include_election_info"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventConfirmationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::TopicConfirmationTypeTypeTable,
    futureheadapi::BlockTypeTable,
    futureheadapi::ElectionInfoTypeTable
  };
  static const char * const names[] = {
    "confirmation_type",
    "account",
    "amount",
    "hash",
    "block_type",
    "block",
    "election_info"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ElectionInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "duration",
    "time",
    "tally",
    "request_count",
    "block_count",
    "voter_count"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ErrorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "code",
    "category",
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SuccessTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IsAliveTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EnvelopeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    futureheadapi::MessageTypeTable
  };
  static const char * const names[] = {
    "time",
    "credentials",
    "correlation_id",
    "message_type",
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const futureheadapi::Envelope *GetEnvelope(const void *buf) {
  return flatbuffers::GetRoot<futureheadapi::Envelope>(buf);
}

inline const futureheadapi::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<futureheadapi::Envelope>(buf);
}

inline Envelope *GetMutableEnvelope(void *buf) {
  return flatbuffers::GetMutableRoot<Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<futureheadapi::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<futureheadapi::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<futureheadapi::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<futureheadapi::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<futureheadapi::EnvelopeT> UnPackEnvelope(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<futureheadapi::EnvelopeT>(GetEnvelope(buf)->UnPack(res));
}

inline std::unique_ptr<futureheadapi::EnvelopeT> UnPackSizePrefixedEnvelope(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<futureheadapi::EnvelopeT>(GetSizePrefixedEnvelope(buf)->UnPack(res));
}

}  // namespace futureheadapi

#endif  // FLATBUFFERS_GENERATED_FUTUREHEADAPI_FUTUREHEADAPI_H_
